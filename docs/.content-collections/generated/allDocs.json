[
  {
    "content": "\n# Animation Patterns\n\nTypeStyles supports CSS animations through the `keyframes` API. This guide covers common animation patterns and best practices.\n\n## Basic animations\n\n### Fade in\n\n```ts\nimport { keyframes, styles } from 'typestyles';\n\nconst fadeIn = keyframes.create('fadeIn', {\n  from: { opacity: 0 },\n  to: { opacity: 1 },\n});\n\nconst card = styles.create('card', {\n  base: {\n    animation: `${fadeIn} 300ms ease`,\n  },\n});\n```\n\n### Slide in\n\n```ts\nconst slideInRight = keyframes.create('slideInRight', {\n  from: {\n    opacity: 0,\n    transform: 'translateX(20px)',\n  },\n  to: {\n    opacity: 1,\n    transform: 'translateX(0)',\n  },\n});\n\nconst slideInLeft = keyframes.create('slideInLeft', {\n  from: {\n    opacity: 0,\n    transform: 'translateX(-20px)',\n  },\n  to: {\n    opacity: 1,\n    transform: 'translateX(0)',\n  },\n});\n\nconst slideInUp = keyframes.create('slideInUp', {\n  from: {\n    opacity: 0,\n    transform: 'translateY(20px)',\n  },\n  to: {\n    opacity: 1,\n    transform: 'translateY(0)',\n  },\n});\n\nconst slideInDown = keyframes.create('slideInDown', {\n  from: {\n    opacity: 0,\n    transform: 'translateY(-20px)',\n  },\n  to: {\n    opacity: 1,\n    transform: 'translateY(0)',\n  },\n});\n```\n\n### Scale animations\n\n```ts\nconst scaleIn = keyframes.create('scaleIn', {\n  from: {\n    opacity: 0,\n    transform: 'scale(0.9)',\n  },\n  to: {\n    opacity: 1,\n    transform: 'scale(1)',\n  },\n});\n\nconst scaleOut = keyframes.create('scaleOut', {\n  from: {\n    opacity: 1,\n    transform: 'scale(1)',\n  },\n  to: {\n    opacity: 0,\n    transform: 'scale(0.9)',\n  },\n});\n\nconst popIn = keyframes.create('popIn', {\n  '0%': { transform: 'scale(0)' },\n  '70%': { transform: 'scale(1.1)' },\n  '100%': { transform: 'scale(1)' },\n});\n```\n\n## Common UI animations\n\n### Loading spinner\n\n```ts\nconst spin = keyframes.create('spin', {\n  from: { transform: 'rotate(0deg)' },\n  to: { transform: 'rotate(360deg)' },\n});\n\nconst spinner = styles.create('spinner', {\n  base: {\n    display: 'inline-block',\n    width: '24px',\n    height: '24px',\n    border: '3px solid #e5e7eb',\n    borderTopColor: '#3b82f6',\n    borderRadius: '50%',\n    animation: `${spin} 800ms linear infinite`,\n  },\n\n  sm: {\n    width: '16px',\n    height: '16px',\n    borderWidth: '2px',\n  },\n\n  lg: {\n    width: '32px',\n    height: '32px',\n    borderWidth: '4px',\n  },\n});\n```\n\n### Pulse animation\n\n```ts\nconst pulse = keyframes.create('pulse', {\n  '0%, 100%': { opacity: 1 },\n  '50%': { opacity: 0.5 },\n});\n\nconst skeleton = styles.create('skeleton', {\n  base: {\n    backgroundColor: '#e5e7eb',\n    borderRadius: '4px',\n    animation: `${pulse} 2s ease-in-out infinite`,\n  },\n});\n```\n\n### Shake animation (error state)\n\n```ts\nconst shake = keyframes.create('shake', {\n  '0%, 100%': { transform: 'translateX(0)' },\n  '10%, 30%, 50%, 70%, 90%': { transform: 'translateX(-4px)' },\n  '20%, 40%, 60%, 80%': { transform: 'translateX(4px)' },\n});\n\nconst input = styles.create('input', {\n  base: { ... },\n  error: {\n    borderColor: '#ef4444',\n    animation: `${shake} 500ms ease-in-out`,\n  },\n});\n```\n\n### Bounce animation\n\n```ts\nconst bounce = keyframes.create('bounce', {\n  '0%, 100%': {\n    transform: 'translateY(0)',\n    animationTimingFunction: 'cubic-bezier(0.8, 0, 1, 1)',\n  },\n  '50%': {\n    transform: 'translateY(-25%)',\n    animationTimingFunction: 'cubic-bezier(0, 0, 0.2, 1)',\n  },\n});\n\nconst notification = styles.create('notification', {\n  badge: {\n    animation: `${bounce} 1s infinite`,\n  },\n});\n```\n\n## Page transitions\n\n### Page fade\n\n```ts\nconst pageFadeIn = keyframes.create('pageFadeIn', {\n  from: { opacity: 0 },\n  to: { opacity: 1 },\n});\n\nconst pageLayout = styles.create('page', {\n  container: {\n    animation: `${pageFadeIn} 300ms ease`,\n  },\n});\n```\n\n### Staggered list items\n\n```ts\n// Individual item animation\nconst listItemFadeIn = keyframes.create('listItemFadeIn', {\n  from: {\n    opacity: 0,\n    transform: 'translateY(10px)',\n  },\n  to: {\n    opacity: 1,\n    transform: 'translateY(0)',\n  },\n});\n\n// Delay classes for stagger effect\nconst list = styles.create('list', {\n  item: {\n    opacity: 0,\n    animation: `${listItemFadeIn} 300ms ease forwards`,\n  },\n\n  itemDelay1: { animationDelay: '50ms' },\n  itemDelay2: { animationDelay: '100ms' },\n  itemDelay3: { animationDelay: '150ms' },\n  itemDelay4: { animationDelay: '200ms' },\n  itemDelay5: { animationDelay: '250ms' },\n});\n\n// React usage with index\nfunction List({ items }) {\n  return (\n    <ul>\n      {items.map((item, index) => (\n        <li\n          key={item.id}\n          className={list(\n            'item',\n            index === 0 && 'itemDelay1',\n            index === 1 && 'itemDelay2',\n            index === 2 && 'itemDelay3',\n            // ... or use a function to calculate delay\n          )}\n        >\n          {item.name}\n        </li>\n      ))}\n    </ul>\n  );\n}\n```\n\n## Micro-interactions\n\n### Button press\n\n```ts\nconst buttonPress = keyframes.create('buttonPress', {\n  '0%': { transform: 'scale(1)' },\n  '50%': { transform: 'scale(0.95)' },\n  '100%': { transform: 'scale(1)' },\n});\n\nconst button = styles.create('button', {\n  base: {\n    transition: 'transform 100ms ease',\n\n    '&:active': {\n      transform: 'scale(0.95)',\n    },\n  },\n\n  // Or with keyframe for more control\n  press: {\n    animation: `${buttonPress} 150ms ease`,\n  },\n});\n```\n\n### Checkbox check\n\n```ts\nconst checkmark = keyframes.create('checkmark', {\n  '0%': {\n    strokeDashoffset: 100,\n  },\n  '100%': {\n    strokeDashoffset: 0,\n  },\n});\n\nconst checkbox = styles.create('checkbox', {\n  base: { ... },\n\n  checkmark: {\n    strokeDasharray: 100,\n    strokeDashoffset: 100,\n  },\n\n  checked: {\n    '& .checkmark': {\n      animation: `${checkmark} 200ms ease forwards`,\n    },\n  },\n});\n```\n\n### Hover lift effect\n\n```ts\nconst card = styles.create('card', {\n  base: {\n    transition: 'transform 200ms ease, box-shadow 200ms ease',\n  },\n\n  interactive: {\n    cursor: 'pointer',\n\n    '&:hover': {\n      transform: 'translateY(-4px)',\n      boxShadow: '0 12px 24px rgba(0, 0, 0, 0.15)',\n    },\n  },\n});\n```\n\n## Complex animations\n\n### Modal enter/exit\n\n```ts\nconst modalBackdropFadeIn = keyframes.create('modalBackdropFadeIn', {\n  from: { opacity: 0 },\n  to: { opacity: 1 },\n});\n\nconst modalBackdropFadeOut = keyframes.create('modalBackdropFadeOut', {\n  from: { opacity: 1 },\n  to: { opacity: 0 },\n});\n\nconst modalContentSlideIn = keyframes.create('modalContentSlideIn', {\n  from: {\n    opacity: 0,\n    transform: 'scale(0.95) translateY(10px)',\n  },\n  to: {\n    opacity: 1,\n    transform: 'scale(1) translateY(0)',\n  },\n});\n\nconst modalContentSlideOut = keyframes.create('modalContentSlideOut', {\n  from: {\n    opacity: 1,\n    transform: 'scale(1) translateY(0)',\n  },\n  to: {\n    opacity: 0,\n    transform: 'scale(0.95) translateY(10px)',\n  },\n});\n\nconst modal = styles.create('modal', {\n  backdrop: {\n    position: 'fixed',\n    inset: 0,\n    backgroundColor: 'rgba(0, 0, 0, 0.5)',\n  },\n\n  backdropEnter: {\n    animation: `${modalBackdropFadeIn} 200ms ease`,\n  },\n\n  backdropExit: {\n    animation: `${modalBackdropFadeOut} 200ms ease forwards`,\n  },\n\n  content: {\n    backgroundColor: 'white',\n    borderRadius: '8px',\n    padding: '24px',\n  },\n\n  contentEnter: {\n    animation: `${modalContentSlideIn} 300ms ease`,\n  },\n\n  contentExit: {\n    animation: `${modalContentSlideOut} 200ms ease forwards`,\n  },\n});\n```\n\n### Toast notifications\n\n```ts\nconst toastSlideIn = keyframes.create('toastSlideIn', {\n  from: {\n    opacity: 0,\n    transform: 'translateX(100%)',\n  },\n  to: {\n    opacity: 1,\n    transform: 'translateX(0)',\n  },\n});\n\nconst toastSlideOut = keyframes.create('toastSlideOut', {\n  from: {\n    opacity: 1,\n    transform: 'translateX(0)',\n  },\n  to: {\n    opacity: 0,\n    transform: 'translateX(100%)',\n  },\n});\n\nconst toastProgress = keyframes.create('toastProgress', {\n  from: { transform: 'scaleX(1)' },\n  to: { transform: 'scaleX(0)' },\n});\n\nconst toast = styles.create('toast', {\n  base: {\n    padding: '16px 20px',\n    borderRadius: '8px',\n    boxShadow: '0 4px 12px rgba(0, 0, 0, 0.15)',\n  },\n\n  enter: {\n    animation: `${toastSlideIn} 300ms ease`,\n  },\n\n  exit: {\n    animation: `${toastSlideOut} 300ms ease forwards`,\n  },\n\n  progressBar: {\n    height: '3px',\n    backgroundColor: 'rgba(255, 255, 255, 0.3)',\n    marginTop: '12px',\n    transformOrigin: 'left',\n    animation: `${toastProgress} 5000ms linear forwards`,\n  },\n\n  success: {\n    backgroundColor: '#10b981',\n    color: 'white',\n  },\n\n  error: {\n    backgroundColor: '#ef4444',\n    color: 'white',\n  },\n\n  info: {\n    backgroundColor: '#3b82f6',\n    color: 'white',\n  },\n});\n```\n\n### Skeleton loading\n\n```ts\nconst shimmer = keyframes.create('shimmer', {\n  '0%': { backgroundPosition: '-200% 0' },\n  '100%': { backgroundPosition: '200% 0' },\n});\n\nconst skeleton = styles.create('skeleton', {\n  base: {\n    backgroundColor: '#e5e7eb',\n    borderRadius: '4px',\n  },\n\n  animated: {\n    background: 'linear-gradient(90deg, #e5e7eb 25%, #f3f4f6 50%, #e5e7eb 75%)',\n    backgroundSize: '200% 100%',\n    animation: `${shimmer} 1.5s infinite`,\n  },\n\n  text: {\n    height: '1em',\n    marginBottom: '0.5em',\n  },\n\n  textLarge: {\n    height: '1.5em',\n  },\n\n  circle: {\n    borderRadius: '50%',\n  },\n\n  avatar: {\n    width: '40px',\n    height: '40px',\n  },\n\n  card: {\n    height: '200px',\n  },\n});\n```\n\n## Scroll animations\n\n### Infinite scroll indicator\n\n```ts\nconst scrollIndicator = keyframes.create('scrollIndicator', {\n  '0%, 100%': {\n    opacity: 1,\n    transform: 'translateY(0)',\n  },\n  '50%': {\n    opacity: 0.5,\n    transform: 'translateY(6px)',\n  },\n});\n\nconst scrollCue = styles.create('scroll-cue', {\n  base: {\n    display: 'flex',\n    flexDirection: 'column',\n    alignItems: 'center',\n    gap: '4px',\n  },\n\n  arrow: {\n    animation: `${scrollIndicator} 1.5s ease-in-out infinite`,\n  },\n\n  arrowDelay1: { animationDelay: '0ms' },\n  arrowDelay2: { animationDelay: '150ms' },\n  arrowDelay3: { animationDelay: '300ms' },\n});\n```\n\n## Best practices\n\n### Performance\n\n```ts\n// ✅ Use transform and opacity for smooth animations\nconst goodAnimation = keyframes.create('goodAnimation', {\n  from: {\n    opacity: 0,\n    transform: 'translateY(20px)', // GPU accelerated\n  },\n  to: {\n    opacity: 1,\n    transform: 'translateY(0)',\n  },\n});\n\n// ❌ Avoid animating layout properties\nconst badAnimation = keyframes.create('badAnimation', {\n  from: {\n    height: 0, // Triggers layout\n    marginTop: 0, // Triggers layout\n  },\n  to: {\n    height: '100px',\n    marginTop: '20px',\n  },\n});\n```\n\n### Accessibility\n\n```ts\n// Respect reduced motion preference\nconst animated = styles.create('animated', {\n  base: {\n    '@media (prefers-reduced-motion: reduce)': {\n      animation: 'none',\n      transition: 'none',\n    },\n  },\n});\n```\n\n### Timing functions\n\n```ts\n// Standard curves\nconst ease = 'ease'; // Standard\nconst easeIn = 'ease-in'; // Accelerate\nconst easeOut = 'ease-out'; // Decelerate\nconst easeInOut = 'ease-in-out'; // Both\n\n// Custom cubic-bezier for specific feels\nconst springy = 'cubic-bezier(0.68, -0.55, 0.265, 1.55)';\nconst smooth = 'cubic-bezier(0.4, 0, 0.2, 1)';\nconst enter = 'cubic-bezier(0, 0, 0.2, 1)';\nconst exit = 'cubic-bezier(0.4, 0, 1, 1)';\n\n// Usage\nconst button = styles.create('button', {\n  base: {\n    transition: `transform 200ms ${springy}`,\n  },\n});\n```\n\n### Duration guidelines\n\n| Animation Type    | Duration  | Use Case                    |\n| ----------------- | --------- | --------------------------- |\n| Micro-interaction | 100-200ms | Button press, hover states  |\n| Standard          | 200-300ms | Modals, dropdowns, tooltips |\n| Complex           | 300-500ms | Page transitions, reveals   |\n| Ambient           | 1-10s     | Loading states, skeletons   |\n\n### Naming conventions\n\n```ts\n// Use descriptive names\nconst fadeIn = keyframes.create('fadeIn', { ... });\nconst slideUp = keyframes.create('slideUp', { ... });\nconst modalEnter = keyframes.create('modalEnter', { ... });\nconst modalExit = keyframes.create('modalExit', { ... });\n\n// Include direction when applicable\nconst slideInRight = keyframes.create('slideInRight', { ... });\nconst slideInLeft = keyframes.create('slideInLeft', { ... });\nconst slideOutUp = keyframes.create('slideOutUp', { ... });\n```\n\n## Animation utilities\n\n### Animation delay helper\n\n```ts\nfunction createStaggeredAnimation(\n  baseName: string,\n  itemCount: number,\n  baseDelay: number\n): Record<string, string> {\n  const delays: Record<string, string> = {};\n\n  for (let i = 0; i < itemCount; i++) {\n    delays[`delay${i + 1}`] = `${baseDelay * (i + 1)}ms`;\n  }\n\n  return delays;\n}\n\n// Usage in React\nfunction StaggeredList({ items }) {\n  const delayClass = (index: number) => {\n    const delays = ['delay1', 'delay2', 'delay3', 'delay4', 'delay5'];\n    return delays[index] || 'delay5';\n  };\n\n  return (\n    <ul>\n      {items.map((item, index) => (\n        <li\n          key={item.id}\n          className={list('item', delayClass(index))}\n        >\n          {item.name}\n        </li>\n      ))}\n    </ul>\n  );\n}\n```\n\n### Animation presets\n\n```ts\n// animations/presets.ts\nexport const presets = {\n  fade: {\n    in: 'fadeIn 300ms ease',\n    out: 'fadeOut 200ms ease',\n  },\n  slide: {\n    up: 'slideUp 300ms ease',\n    down: 'slideDown 300ms ease',\n    left: 'slideLeft 300ms ease',\n    right: 'slideRight 300ms ease',\n  },\n  scale: {\n    in: 'scaleIn 200ms ease',\n    out: 'scaleOut 200ms ease',\n  },\n  bounce: 'bounce 500ms ease',\n  pulse: 'pulse 2s ease-in-out infinite',\n  spin: 'spin 1s linear infinite',\n  shake: 'shake 500ms ease-in-out',\n} as const;\n\n// Usage\nconst modal = styles.create('modal', {\n  enter: {\n    animation: presets.fade.in,\n  },\n});\n```\n\n## Summary\n\n1. **Use transform and opacity** - Best performance\n2. **Respect reduced motion** - Accessibility first\n3. **Keep animations purposeful** - Don't animate just because you can\n4. **Use appropriate timing** - Match animation to importance\n5. **Consider physics** - Natural motion feels better\n6. **Test on real devices** - Performance varies\n7. **Name descriptively** - Make intent clear\n8. **Reuse animations** - Create a preset library\n9. **Document timing** - Help other developers\n10. **Test with users** - Get feedback on feel\n",
    "title": "Animation Patterns",
    "description": "Common animation patterns and techniques with typestyles",
    "_meta": {
      "filePath": "animation-patterns.md",
      "fileName": "animation-patterns.md",
      "directory": ".",
      "extension": "md",
      "path": "animation-patterns"
    }
  },
  {
    "content": "\n# API Reference\n\nAuto-generated documentation for all typestyles APIs.\n\n## Core Exports\n\n### `styles`\n\nStyle creation API.\n\n**Methods:**\n\n- `styles.create(namespace, definitions)`: Style creation API\n\n\n### `tokens`\n\nDesign token API using CSS custom properties.\n\n**Methods:**\n\n- `tokens.create(namespace, values)`: Creates CSS custom properties\n- `tokens.use(namespace)`: References existing tokens\n- `tokens.createTheme(name, overrides)`: Creates theme class\n\n### `keyframes`\n\nKeyframe animation API.\n\n**Methods:**\n\n- `keyframes.create(name, stops)`: Creates @keyframes animation\n\n## Usage Examples\n\n### Creating Styles\n\n```ts\nimport { styles } from 'typestyles';\n\nconst button = styles.create('button', {\n  base: { padding: '8px 16px' },\n  primary: { backgroundColor: '#0066ff' },\n});\n\nbutton('base', 'primary'); // \"button-base button-primary\"\n```\n\n### Creating Tokens\n\n```ts\nimport { tokens } from 'typestyles';\n\nconst color = tokens.create('color', {\n  primary: '#0066ff',\n  secondary: '#6b7280',\n});\n\ncolor.primary; // \"var(--color-primary)\"\n```\n\n### Creating Animations\n\n```ts\nimport { keyframes } from 'typestyles';\n\nconst fadeIn = keyframes.create('fadeIn', {\n  from: { opacity: 0 },\n  to: { opacity: 1 },\n});\n\n// Use in styles\nanimation: `${fadeIn} 300ms ease`\n```\n\n---\n\n*This API reference was auto-generated from source code.*\n*Last updated: 2026-02-15*\n",
    "title": "API Reference",
    "description": "Complete API reference for typestyles",
    "_meta": {
      "filePath": "api-reference.md",
      "fileName": "api-reference.md",
      "directory": ".",
      "extension": "md",
      "path": "api-reference"
    }
  },
  {
    "content": "\n# Best Practices\n\nThese guidelines will help you write maintainable, scalable code with typestyles.\n\n## Naming conventions\n\n### Namespaces\n\nUse kebab-case for namespaces. The namespace should describe the component or pattern:\n\n```ts\n// ✅ Good - descriptive and consistent\nconst button = styles.create('button', { ... });\nconst card = styles.create('card', { ... });\nconst navigationMenu = styles.create('navigation-menu', { ... });\n\n// ❌ Avoid - generic or single-letter names\nconst b = styles.create('b', { ... });\nconst x = styles.create('x', { ... });\nconst component = styles.create('component', { ... });\n```\n\n### Variants\n\nUse camelCase for variant names. Be descriptive about the style purpose, not just the visual appearance:\n\n```ts\nconst button = styles.create('button', {\n  // ✅ Good - describes the intent\n  base: { ... },           // The foundation styles\n  primary: { ... },        // The main action\n  secondary: { ... },      // Alternative action\n  danger: { ... },         // Destructive action\n  ghost: { ... },          // Subtle action\n\n  // Size variants\n  small: { ... },\n  medium: { ... },\n  large: { ... },\n\n  // State variants\n  disabled: { ... },\n  loading: { ... },\n\n  // ❌ Avoid - describes appearance only\n  blue: { ... },\n  big: { ... },\n  rounded: { ... },\n});\n```\n\n### Tokens\n\nGroup tokens by category. Use consistent naming within groups:\n\n```ts\n// ✅ Good - clear categories and consistent naming\nexport const color = tokens.create('color', {\n  // Semantic colors\n  primary: '#0066ff',\n  secondary: '#6b7280',\n  success: '#10b981',\n  warning: '#f59e0b',\n  danger: '#ef4444',\n\n  // Neutral scale\n  gray50: '#f9fafb',\n  gray100: '#f3f4f6',\n  gray200: '#e5e7eb',\n  // ...etc\n\n  // Text colors\n  text: '#111827',\n  textMuted: '#6b7280',\n  textInverse: '#ffffff',\n\n  // Surface colors\n  surface: '#ffffff',\n  surfaceRaised: '#f9fafb',\n  surfaceSunken: '#f3f4f6',\n});\n\nexport const space = tokens.create('space', {\n  // Scale-based\n  0: '0',\n  1: '4px',\n  2: '8px',\n  3: '12px',\n  4: '16px',\n  5: '20px',\n  6: '24px',\n  8: '32px',\n  10: '40px',\n  12: '48px',\n  16: '64px',\n  20: '80px',\n  24: '96px',\n\n  // Semantic aliases (optional)\n  xs: '4px',\n  sm: '8px',\n  md: '16px',\n  lg: '24px',\n  xl: '32px',\n});\n```\n\n## File organization\n\n### Monorepo/Package structure\n\n```\nsrc/\n├── tokens/\n│   ├── index.ts          # Re-exports all tokens\n│   ├── colors.ts         # Color definitions\n│   ├── spacing.ts        # Spacing scale\n│   ├── typography.ts     # Font sizes, line heights\n│   ├── radii.ts          # Border radius\n│   └── shadows.ts        # Box shadows\n├── components/\n│   ├── Button/\n│   │   ├── index.ts      # Component export\n│   │   ├── Button.tsx    # Component implementation\n│   │   └── Button.styles.ts  # Style definitions\n│   ├── Card/\n│   │   ├── index.ts\n│   │   ├── Card.tsx\n│   │   └── Card.styles.ts\n│   └── ...\n├── layouts/\n│   ├── Layout.styles.ts\n│   └── ...\n└── utils/\n    └── styles.ts         # Shared utility styles\n```\n\n### Token files\n\nKeep tokens in dedicated files, grouped by category:\n\n```ts\n// tokens/colors.ts\nimport { tokens } from 'typestyles';\n\nexport const color = tokens.create('color', {\n  // Brand colors\n  brand50: '#eff6ff',\n  brand100: '#dbeafe',\n  brand500: '#3b82f6',\n  brand600: '#2563eb',\n  brand700: '#1d4ed8',\n\n  // Neutral scale\n  gray50: '#f9fafb',\n  gray100: '#f3f4f6',\n  // ... etc\n});\n\n// tokens/index.ts\nexport { color } from './colors';\nexport { space } from './spacing';\nexport { font } from './typography';\n```\n\n### Component style files\n\nKeep styles co-located with components or in a separate `.styles.ts` file:\n\n**Option 1: Same file (for simple components)**\n\n```tsx\n// Button.tsx\nimport { styles } from 'typestyles';\nimport { color, space } from '../tokens';\n\nconst button = styles.create('button', {\n  base: { ... },\n  primary: { ... },\n});\n\nexport function Button({ variant, children }) {\n  return <button className={button('base', variant)}>{children}</button>;\n}\n```\n\n**Option 2: Separate file (for complex components)**\n\n```ts\n// Button.styles.ts\nimport { styles } from 'typestyles';\nimport { color, space } from '../tokens';\n\nexport const button = styles.create('button', {\n  base: { ... },\n  primary: { ... },\n  secondary: { ... },\n  // ... many variants\n});\n\n// Button.tsx\nimport { button } from './Button.styles';\n\nexport function Button({ variant, children }) {\n  return <button className={button('base', variant)}>{children}</button>;\n}\n```\n\n## Token architecture\n\n### Semantic vs. literal tokens\n\nUse literal tokens for the design system foundation, semantic tokens for application use:\n\n```ts\n// tokens/primitives.ts\n// Raw values from your design system\nexport const primitives = {\n  colors: {\n    blue500: '#0066ff',\n    blue600: '#0052cc',\n    gray500: '#6b7280',\n    red500: '#ef4444',\n  },\n  space: {\n    1: '4px',\n    2: '8px',\n    3: '16px',\n    4: '24px',\n  },\n};\n\n// tokens/semantic.ts\n// Semantic meanings mapped to primitives\nexport const color = tokens.create('color', {\n  primary: primitives.colors.blue500,\n  primaryHover: primitives.colors.blue600,\n  secondary: primitives.colors.gray500,\n  danger: primitives.colors.red500,\n  // ... etc\n});\n\nexport const space = tokens.create('space', primitives.space);\n```\n\n### Component-specific tokens\n\nFor complex components, you can scope tokens to just that component:\n\n```ts\n// components/Calendar/Calendar.tokens.ts\nimport { tokens } from 'typestyles';\n\nexport const calendar = tokens.create('calendar', {\n  daySize: '40px',\n  headerHeight: '48px',\n  gridGap: '4px',\n});\n\n// Usage in Calendar.styles.ts\nimport { calendar } from './Calendar.tokens';\n\nconst calendarStyles = styles.create('calendar', {\n  day: {\n    width: calendar.daySize,\n    height: calendar.daySize,\n  },\n});\n```\n\n### Token composition\n\nReference other tokens when defining new ones:\n\n```ts\nconst space = tokens.create('space', {\n  1: '4px',\n  2: '8px',\n  3: '16px',\n  4: '24px',\n  5: '32px',\n});\n\nconst size = tokens.create('size', {\n  // Reference space tokens for consistency\n  sm: space[1], // 4px\n  md: space[2], // 8px\n  lg: space[3], // 16px\n  icon: space[4], // 24px\n});\n```\n\n## Component patterns\n\n### Compound components\n\nFor related components (like Form + Input + Label), use consistent namespacing:\n\n```ts\nconst form = styles.create('form', {\n  root: { ... },\n  field: { ... },\n});\n\nconst input = styles.create('input', {\n  base: { ... },\n  error: { ... },\n});\n\nconst label = styles.create('label', {\n  base: { ... },\n  required: { ... },\n});\n\n// Usage\n<form className={form('root')}>\n  <div className={form('field')}>\n    <label className={label('base', 'required')}>Name</label>\n    <input className={input('base', error && 'error')} />\n  </div>\n</form>\n```\n\n### Variant composition\n\nCompose variants from base to specific:\n\n```ts\nconst button = styles.create('button', {\n  // Base styles every button has\n  base: {\n    display: 'inline-flex',\n    alignItems: 'center',\n    justifyContent: 'center',\n    cursor: 'pointer',\n    border: 'none',\n    fontWeight: 500,\n    transition: 'all 150ms ease',\n  },\n\n  // Visual variants\n  primary: { backgroundColor: color.primary, color: '#fff' },\n  secondary: { backgroundColor: color.secondary, color: '#fff' },\n  ghost: { backgroundColor: 'transparent' },\n\n  // Size variants\n  small: { padding: '4px 8px', fontSize: '12px' },\n  medium: { padding: '8px 16px', fontSize: '14px' },\n  large: { padding: '12px 24px', fontSize: '16px' },\n\n  // State variants\n  disabled: { opacity: 0.5, cursor: 'not-allowed' },\n  loading: { cursor: 'wait' },\n});\n\n// Usage\nbutton('base', 'primary', 'medium'); // Primary medium button\nbutton('base', 'primary', 'medium', 'disabled'); // Disabled primary medium\nbutton('base', 'ghost', 'small'); // Small ghost button\n```\n\n### Layout components\n\nUse layout components with flexible spacing:\n\n```ts\nconst stack = styles.create('stack', {\n  base: {\n    display: 'flex',\n    flexDirection: 'column',\n  },\n  // Spacing variants\n  gap1: { gap: space[1] },\n  gap2: { gap: space[2] },\n  gap3: { gap: space[3] },\n  gap4: { gap: space[4] },\n});\n\nconst row = styles.create('row', {\n  base: {\n    display: 'flex',\n    flexDirection: 'row',\n    alignItems: 'center',\n  },\n  gap1: { gap: space[1] },\n  gap2: { gap: space[2] },\n  // ... etc\n});\n```\n\n## State management\n\n### Boolean variants\n\nFor simple on/off states:\n\n```ts\nconst card = styles.create('card', {\n  base: { ... },\n  elevated: {\n    boxShadow: '0 4px 6px rgba(0,0,0,0.1)',\n  },\n  interactive: {\n    cursor: 'pointer',\n    '&:hover': {\n      boxShadow: '0 8px 12px rgba(0,0,0,0.15)',\n    },\n  },\n});\n\n// Usage\ncard('base', isElevated && 'elevated', isInteractive && 'interactive');\n```\n\n### Complex state\n\nFor more complex state combinations, consider using a helper:\n\n```ts\nfunction getButtonClasses({ variant, size, isDisabled, isLoading }: ButtonProps) {\n  return button(\n    'base',\n    variant, // 'primary' | 'secondary' | 'ghost'\n    size, // 'small' | 'medium' | 'large'\n    isDisabled && 'disabled',\n    isLoading && 'loading',\n  );\n}\n```\n\n## Theming patterns\n\n### Dark mode with createTheme\n\n```ts\n// tokens/index.ts\nexport const color = tokens.create('color', {\n  text: '#111827',\n  textMuted: '#6b7280',\n  surface: '#ffffff',\n  surfaceRaised: '#f9fafb',\n});\n\nexport const darkTheme = tokens.createTheme('dark', {\n  color: {\n    text: '#e0e0e0',\n    textMuted: '#9ca3af',\n    surface: '#1a1a2e',\n    surfaceRaised: '#25253e',\n  },\n});\n\n// Apply theme to document body or specific container\ndocument.body.classList.add(darkTheme);\n```\n\n### Multiple themes\n\n```ts\nconst brandLight = tokens.createTheme('brand-light', { ... });\nconst brandDark = tokens.createTheme('brand-dark', { ... });\nconst highContrast = tokens.createTheme('high-contrast', { ... });\n```\n\n## Code style\n\n### Consistent formatting\n\n```ts\n// ✅ Good - consistent structure\nconst card = styles.create('card', {\n  base: {\n    padding: space[4],\n    borderRadius: '8px',\n    backgroundColor: color.surface,\n  },\n\n  elevated: {\n    boxShadow: shadow.md,\n  },\n\n  interactive: {\n    cursor: 'pointer',\n    transition: 'box-shadow 200ms ease',\n    '&:hover': {\n      boxShadow: shadow.lg,\n    },\n  },\n});\n\n// ❌ Avoid - inconsistent formatting\nconst card = styles.create('card', {\n  base: { padding: space[4], borderRadius: '8px', backgroundColor: color.surface },\n  elevated: { boxShadow: shadow.md },\n});\n```\n\n### Import organization\n\n```ts\n// 1. External imports\nimport React from 'react';\nimport { styles, tokens } from 'typestyles';\n\n// 2. Internal absolute imports\nimport { color, space } from '@/tokens';\nimport { Button } from '@/components';\n\n// 3. Internal relative imports\nimport { card } from './Card.styles';\nimport { useCardState } from './useCardState';\n```\n\n## Performance tips\n\n1. **Define styles at module level** - Never create styles inside components\n2. **Reuse token references** - Define once, import many times\n3. **Minimize variants** - Don't create a variant for every possible state\n4. **Use inline styles for dynamic values** - Don't create styles for frequently changing values\n5. **Lazy load component styles** - Use dynamic imports for code splitting\n\n## Common mistakes to avoid\n\n### ❌ Creating styles inside components\n\n```tsx\n// Bad - creates new styles on every render\nfunction Button({ children }) {\n  const button = styles.create('button', { base: { ... } }); // ❌\n  return <button className={button('base')}>{children}</button>;\n}\n\n// Good - define at module level\nconst button = styles.create('button', { base: { ... } });\n\nfunction Button({ children }) {\n  return <button className={button('base')}>{children}</button>;\n}\n```\n\n### ❌ Dynamic style values\n\n```tsx\n// Bad - creates styles for every possible value\nconst button = styles.create('button', {\n  base: { width: props.width }, // ❌ Don't do this\n});\n\n// Good - use inline styles for dynamic values\nconst button = styles.create('button', {\n  base: { display: 'inline-block' },\n});\n\nfunction Button({ width, children }) {\n  return (\n    <button\n      className={button('base')}\n      style={{ width }} // ✅ Dynamic value here\n    >\n      {children}\n    </button>\n  );\n}\n```\n\n### ❌ Duplicate namespaces\n\n```ts\n// File A\nconst button = styles.create('button', { ... });\n\n// File B\nconst button = styles.create('button', { ... }); // ❌ Collision!\n\n// Good - use descriptive names\nconst iconButton = styles.create('icon-button', { ... });\nconst textButton = styles.create('text-button', { ... });\n```\n\n## Summary\n\n- Use descriptive, consistent naming for namespaces and variants\n- Organize tokens by category in dedicated files\n- Define styles at module level, never in components\n- Use semantic tokens for application code\n- Keep variants focused on style purpose, not appearance\n- Use inline styles for truly dynamic values\n- Use the Vite plugin to catch duplicate namespaces\n",
    "title": "Best Practices",
    "description": "Tips for organizing and maintaining typestyles in your project",
    "_meta": {
      "filePath": "best-practices.md",
      "fileName": "best-practices.md",
      "directory": ".",
      "extension": "md",
      "path": "best-practices"
    }
  },
  {
    "content": "\n# Color\n\nThe `color` API provides type-safe helpers for modern CSS color functions. These functions return plain CSS strings (no runtime color math), so they compose naturally with token references and other CSS values.\n\n## Basic color functions\n\n### rgb\n\nCreate `rgb()` colors with space-separated syntax:\n\n```ts\nimport { color } from 'typestyles';\n\ncolor.rgb(0, 102, 255); // \"rgb(0 102 255)\"\ncolor.rgb(0, 102, 255, 0.5); // \"rgb(0 102 255 / 0.5)\"\n```\n\n### hsl\n\nCreate `hsl()` colors:\n\n```ts\ncolor.hsl(220, '100%', '50%'); // \"hsl(220 100% 50%)\"\ncolor.hsl(220, '100%', '50%', 0.8); // \"hsl(220 100% 50% / 0.8)\"\n```\n\n### oklch\n\nCreate `oklch()` colors for perceptually uniform color spaces:\n\n```ts\ncolor.oklch(0.7, 0.15, 250); // \"oklch(0.7 0.15 250)\"\ncolor.oklch(0.7, 0.15, 250, 0.5); // \"oklch(0.7 0.15 250 / 0.5)\"\n```\n\n### oklab\n\nCreate `oklab()` colors:\n\n```ts\ncolor.oklab(0.7, -0.1, -0.1); // \"oklab(0.7 -0.1 -0.1)\"\ncolor.oklab(0.7, -0.1, -0.1, 0.5); // \"oklab(0.7 -0.1 -0.1 / 0.5)\"\n```\n\n### lab\n\nCreate `lab()` colors:\n\n```ts\ncolor.lab('50%', 40, -20); // \"lab(50% 40 -20)\"\n```\n\n### lch\n\nCreate `lch()` colors:\n\n```ts\ncolor.lch('50%', 80, 250); // \"lch(50% 80 250)\"\n```\n\n### hwb\n\nCreate `hwb()` colors:\n\n```ts\ncolor.hwb(220, '10%', '0%'); // \"hwb(220 10% 0%)\"\n```\n\n## Advanced color functions\n\n### mix\n\nMix two colors using `color-mix()`:\n\n```ts\n// Mix red and blue equally (50/50)\ncolor.mix('red', 'blue');\n// \"color-mix(in srgb, red, blue)\"\n\n// Mix 30% red with 70% blue\ncolor.mix('red', 'blue', 30);\n// \"color-mix(in srgb, red 30%, blue)\"\n\n// Mix in a different color space\ncolor.mix('red', 'blue', 50, 'oklch');\n// \"color-mix(in oklch, red 50%, blue)\"\n```\n\nWorks great with token references:\n\n```ts\nconst theme = tokens.create('theme', {\n  primary: '#0066ff',\n});\n\n// Create a lighter variant of your primary color\ncolor.mix(theme.primary, 'white', 20);\n// \"color-mix(in srgb, var(--theme-primary) 20%, white)\"\n```\n\n### alpha\n\nAdjust the opacity of any color:\n\n```ts\ncolor.alpha('red', 0.5); // \"color-mix(in srgb, red 50%, transparent)\"\ncolor.alpha(theme.primary, 0.2); // \"color-mix(in srgb, var(--theme-primary) 20%, transparent)\"\ncolor.alpha('#0066ff', 0.8, 'oklch'); // \"color-mix(in oklch, #0066ff 80%, transparent)\"\n```\n\nThis is a convenience wrapper around `color.mix()` that mixes any color with transparent.\n\n### lightDark\n\nUse the `light-dark()` CSS function for automatic light/dark mode switching:\n\n```ts\ncolor.lightDark('#111', '#eee');\n// \"light-dark(#111, #eee)\"\n\n// Works with tokens too\ncolor.lightDark(theme.textLight, theme.textDark);\n// \"light-dark(var(--theme-textLight), var(--theme-textDark))\"\n```\n\nNote: This requires the browser to support `light-dark()` and the element to have an appropriate `color-scheme` value.\n\n## Using with tokens\n\nAll color functions accept token references since tokens are just CSS `var()` strings:\n\n```ts\nconst color = tokens.create('color', {\n  primary: '#0066ff',\n  secondary: '#6b7280',\n});\n\nconst styles = styles.create('card', {\n  base: {\n    backgroundColor: color.mix(color.primary, 'white', 10),\n    borderColor: color.alpha(color.secondary, 0.3),\n  },\n});\n```\n\n## Color spaces for mixing\n\nWhen using `mix()` or `alpha()`, you can specify different color spaces:\n\n- `'srgb'` (default) - Standard RGB, most common\n- `'srgb-linear'` - Linear RGB\n- `'display-p3'` - Wide gamut RGB\n- `'a98-rgb'` - Wide gamut RGB\n- `'prophoto-rgb'` - Very wide gamut\n- `'rec2020'` - Ultra HD color space\n- `'lab'` - CIE Lab color space\n- `'oklab'` - Better Lab, perceptually uniform\n- `'xyz'`, `'xyz-d50'`, `'xyz-d65'` - CIE XYZ\n- `'hsl'` - HSL color space\n- `'hwb'` - HWB color space\n- `'lch'` - CIE LCH\n- `'oklch'` - Better LCH, perceptually uniform\n\n```ts\n// Mix in perceptually uniform space for smoother gradients\ncolor.mix('red', 'blue', 50, 'oklch');\ncolor.alpha(theme.primary, 0.5, 'oklab');\n```\n\n## Why no runtime color math?\n\nUnlike some libraries that parse and manipulate colors in JavaScript, these helpers simply generate CSS strings. This means:\n\n- Zero runtime overhead\n- Colors are computed by the browser (which can use hardware acceleration)\n- Works naturally with CSS custom properties and tokens\n- Respects user's color scheme and accessibility preferences\n- Smaller bundle size\n\nIf you need programmatic color manipulation (e.g., generating a palette programmatically), do that at build time and use the resulting values with these helpers.\n",
    "title": "Color",
    "description": "Type-safe helpers for CSS color functions",
    "_meta": {
      "filePath": "color.md",
      "fileName": "color.md",
      "directory": ".",
      "extension": "md",
      "path": "color"
    }
  },
  {
    "content": "\n# Component Library Setup\n\nThis guide shows you how to set up a reusable component library using typestyles, suitable for publishing to npm.\n\n## Project structure\n\n```\nmy-ui-library/\n├── src/\n│   ├── tokens/\n│   │   ├── index.ts          # Token exports\n│   │   ├── colors.ts         # Color definitions\n│   │   ├── spacing.ts        # Spacing scale\n│   │   └── typography.ts     # Font tokens\n│   ├── components/\n│   │   ├── Button/\n│   │   │   ├── Button.tsx\n│   │   │   ├── Button.styles.ts\n│   │   │   └── index.ts\n│   │   ├── Card/\n│   │   │   ├── Card.tsx\n│   │   │   ├── Card.styles.ts\n│   │   │   └── index.ts\n│   │   ├── Input/\n│   │   │   └── ...\n│   │   └── index.ts          # Component exports\n│   ├── utils/\n│   │   └── style-utils.ts    # Shared style utilities\n│   ├── index.ts              # Main library export\n│   └── styles.css            # Optional global CSS\n├── package.json\n├── tsconfig.json\n├── vite.config.ts\n└── README.md\n```\n\n## Package configuration\n\n### package.json\n\n```json\n{\n  \"name\": \"@myorg/ui-library\",\n  \"version\": \"1.0.0\",\n  \"description\": \"A React component library built with typestyles\",\n  \"type\": \"module\",\n  \"main\": \"./dist/index.js\",\n  \"module\": \"./dist/index.js\",\n  \"types\": \"./dist/index.d.ts\",\n  \"exports\": {\n    \".\": {\n      \"import\": \"./dist/index.js\",\n      \"types\": \"./dist/index.d.ts\"\n    },\n    \"./tokens\": {\n      \"import\": \"./dist/tokens/index.js\",\n      \"types\": \"./dist/tokens/index.d.ts\"\n    },\n    \"./styles.css\": \"./dist/styles.css\"\n  },\n  \"files\": [\"dist\"],\n  \"scripts\": {\n    \"build\": \"tsc && vite build\",\n    \"dev\": \"vite\",\n    \"test\": \"vitest\",\n    \"typecheck\": \"tsc --noEmit\"\n  },\n  \"peerDependencies\": {\n    \"react\": \"^18.0.0\",\n    \"react-dom\": \"^18.0.0\",\n    \"typestyles\": \"^1.0.0\"\n  },\n  \"devDependencies\": {\n    \"@types/react\": \"^18.0.0\",\n    \"typestyles\": \"^1.0.0\",\n    \"typescript\": \"^5.0.0\",\n    \"vite\": \"^5.0.0\"\n  }\n}\n```\n\nNote: `typestyles` should be a peer dependency so consuming apps can control the version.\n\n## Token system\n\n### Colors\n\n```ts\n// src/tokens/colors.ts\nimport { tokens } from 'typestyles';\n\nexport const colors = tokens.create('color', {\n  // Brand\n  brand50: '#eff6ff',\n  brand100: '#dbeafe',\n  brand200: '#bfdbfe',\n  brand300: '#93c5fd',\n  brand400: '#60a5fa',\n  brand500: '#3b82f6',\n  brand600: '#2563eb',\n  brand700: '#1d4ed8',\n  brand800: '#1e40af',\n  brand900: '#1e3a8a',\n\n  // Gray scale\n  gray50: '#f9fafb',\n  gray100: '#f3f4f6',\n  gray200: '#e5e7eb',\n  gray300: '#d1d5db',\n  gray400: '#9ca3af',\n  gray500: '#6b7280',\n  gray600: '#4b5563',\n  gray700: '#374151',\n  gray800: '#1f2937',\n  gray900: '#111827',\n\n  // Semantic\n  success: '#10b981',\n  warning: '#f59e0b',\n  danger: '#ef4444',\n  info: '#3b82f6',\n});\n\n// Semantic aliases\nexport const semanticColors = tokens.create('semantic-color', {\n  primary: colors.brand500,\n  primaryHover: colors.brand600,\n  secondary: colors.gray500,\n  secondaryHover: colors.gray600,\n  text: colors.gray900,\n  textMuted: colors.gray500,\n  background: colors.gray50,\n  surface: '#ffffff',\n  surfaceRaised: colors.gray100,\n  border: colors.gray200,\n});\n```\n\n### Spacing\n\n```ts\n// src/tokens/spacing.ts\nimport { tokens } from 'typestyles';\n\nexport const spacing = tokens.create('space', {\n  0: '0',\n  1: '4px',\n  2: '8px',\n  3: '12px',\n  4: '16px',\n  5: '20px',\n  6: '24px',\n  8: '32px',\n  10: '40px',\n  12: '48px',\n  16: '64px',\n  20: '80px',\n  24: '96px',\n\n  // Semantic aliases\n  xs: '4px',\n  sm: '8px',\n  md: '16px',\n  lg: '24px',\n  xl: '32px',\n  '2xl': '48px',\n  '3xl': '64px',\n});\n```\n\n### Typography\n\n```ts\n// src/tokens/typography.ts\nimport { tokens } from 'typestyles';\n\nexport const fontSize = tokens.create('font-size', {\n  xs: '0.75rem', // 12px\n  sm: '0.875rem', // 14px\n  base: '1rem', // 16px\n  lg: '1.125rem', // 18px\n  xl: '1.25rem', // 20px\n  '2xl': '1.5rem', // 24px\n  '3xl': '1.875rem', // 30px\n  '4xl': '2.25rem', // 36px\n});\n\nexport const fontWeight = tokens.create('font-weight', {\n  normal: '400',\n  medium: '500',\n  semibold: '600',\n  bold: '700',\n});\n\nexport const lineHeight = tokens.create('line-height', {\n  none: '1',\n  tight: '1.25',\n  snug: '1.375',\n  normal: '1.5',\n  relaxed: '1.625',\n  loose: '2',\n});\n```\n\n### Token exports\n\n```ts\n// src/tokens/index.ts\nexport { colors, semanticColors } from './colors';\nexport { spacing } from './spacing';\nexport { fontSize, fontWeight, lineHeight } from './typography';\n```\n\n## Component implementation\n\n### Button component\n\n```ts\n// src/components/Button/Button.styles.ts\nimport { styles } from 'typestyles';\nimport { semanticColors, spacing, fontSize, fontWeight } from '../../tokens';\n\nexport const button = styles.create('button', {\n  base: {\n    display: 'inline-flex',\n    alignItems: 'center',\n    justifyContent: 'center',\n    gap: spacing[2],\n    padding: `${spacing[2]} ${spacing[4]}`,\n    borderRadius: '6px',\n    fontSize: fontSize.base,\n    fontWeight: fontWeight.medium,\n    lineHeight: '1.5',\n    cursor: 'pointer',\n    border: 'none',\n    transition: 'all 150ms ease',\n\n    '&:disabled': {\n      opacity: 0.5,\n      cursor: 'not-allowed',\n    },\n\n    '&:focus': {\n      outline: 'none',\n      boxShadow: `0 0 0 3px ${semanticColors.primary}33`,\n    },\n  },\n\n  primary: {\n    backgroundColor: semanticColors.primary,\n    color: '#ffffff',\n\n    '&:hover:not(:disabled)': {\n      backgroundColor: semanticColors.primaryHover,\n    },\n  },\n\n  secondary: {\n    backgroundColor: semanticColors.secondary,\n    color: '#ffffff',\n\n    '&:hover:not(:disabled)': {\n      backgroundColor: semanticColors.secondaryHover,\n    },\n  },\n\n  outline: {\n    backgroundColor: 'transparent',\n    border: `1px solid ${semanticColors.border}`,\n    color: semanticColors.text,\n\n    '&:hover:not(:disabled)': {\n      backgroundColor: semanticColors.surfaceRaised,\n    },\n  },\n\n  ghost: {\n    backgroundColor: 'transparent',\n    color: semanticColors.text,\n\n    '&:hover:not(:disabled)': {\n      backgroundColor: semanticColors.surfaceRaised,\n    },\n  },\n\n  sm: {\n    padding: `${spacing[1]} ${spacing[3]}`,\n    fontSize: fontSize.sm,\n  },\n\n  md: {\n    padding: `${spacing[2]} ${spacing[4]}`,\n    fontSize: fontSize.base,\n  },\n\n  lg: {\n    padding: `${spacing[3]} ${spacing[6]}`,\n    fontSize: fontSize.lg,\n  },\n\n  fullWidth: {\n    width: '100%',\n  },\n});\n```\n\n```tsx\n// src/components/Button/Button.tsx\nimport { forwardRef, type ButtonHTMLAttributes, type ReactNode } from 'react';\nimport { button } from './Button.styles';\n\nexport interface ButtonProps extends ButtonHTMLAttributes<HTMLButtonElement> {\n  variant?: 'primary' | 'secondary' | 'outline' | 'ghost';\n  size?: 'sm' | 'md' | 'lg';\n  fullWidth?: boolean;\n  children: ReactNode;\n}\n\nexport const Button = forwardRef<HTMLButtonElement, ButtonProps>(\n  ({ variant = 'primary', size = 'md', fullWidth = false, children, className, ...props }, ref) => {\n    return (\n      <button\n        ref={ref}\n        className={button('base', variant, size, fullWidth && 'fullWidth', className)}\n        {...props}\n      >\n        {children}\n      </button>\n    );\n  },\n);\n\nButton.displayName = 'Button';\n```\n\n```ts\n// src/components/Button/index.ts\nexport { Button } from './Button';\nexport type { ButtonProps } from './Button';\n```\n\n## Theming support\n\n### Dark theme\n\n```ts\n// src/tokens/themes.ts\nimport { tokens } from 'typestyles';\n\nexport const darkTheme = tokens.createTheme('dark', {\n  'semantic-color': {\n    primary: '#60a5fa',\n    primaryHover: '#3b82f6',\n    text: '#f9fafb',\n    textMuted: '#9ca3af',\n    background: '#111827',\n    surface: '#1f2937',\n    surfaceRaised: '#374151',\n    border: '#4b5563',\n  },\n});\n\nexport const highContrastTheme = tokens.createTheme('high-contrast', {\n  'semantic-color': {\n    text: '#000000',\n    background: '#ffffff',\n    primary: '#0000ff',\n    border: '#000000',\n  },\n});\n```\n\n### Theme provider\n\n```tsx\n// src/components/ThemeProvider/ThemeProvider.tsx\nimport { createContext, useContext, useState, type ReactNode } from 'react';\nimport { darkTheme } from '../../tokens/themes';\n\ninterface ThemeContextValue {\n  theme: 'light' | 'dark';\n  setTheme: (theme: 'light' | 'dark') => void;\n}\n\nconst ThemeContext = createContext<ThemeContextValue>({\n  theme: 'light',\n  setTheme: () => {},\n});\n\nexport function useTheme() {\n  return useContext(ThemeContext);\n}\n\ninterface ThemeProviderProps {\n  children: ReactNode;\n  defaultTheme?: 'light' | 'dark';\n}\n\nexport function ThemeProvider({ children, defaultTheme = 'light' }: ThemeProviderProps) {\n  const [theme, setTheme] = useState(defaultTheme);\n\n  return (\n    <ThemeContext.Provider value={{ theme, setTheme }}>\n      <div className={theme === 'dark' ? darkTheme : ''}>{children}</div>\n    </ThemeContext.Provider>\n  );\n}\n```\n\n## Build configuration\n\n### Vite config\n\n```ts\n// vite.config.ts\nimport { defineConfig } from 'vite';\nimport react from '@vitejs/plugin-react';\nimport dts from 'vite-plugin-dts';\nimport path from 'path';\n\nexport default defineConfig({\n  plugins: [\n    react(),\n    dts({\n      insertTypesEntry: true,\n    }),\n  ],\n  build: {\n    lib: {\n      entry: path.resolve(__dirname, 'src/index.ts'),\n      name: 'MyUILibrary',\n      formats: ['es', 'cjs'],\n      fileName: (format) => `index.${format === 'es' ? 'js' : 'cjs'}`,\n    },\n    rollupOptions: {\n      external: ['react', 'react-dom', 'typestyles'],\n      output: {\n        globals: {\n          react: 'React',\n          'react-dom': 'ReactDOM',\n          typestyles: 'TypeStyles',\n        },\n      },\n    },\n  },\n});\n```\n\n### TypeScript config\n\n```json\n// tsconfig.json\n{\n  \"compilerOptions\": {\n    \"target\": \"ES2020\",\n    \"useDefineForClassFields\": true,\n    \"lib\": [\"ES2020\", \"DOM\", \"DOM.Iterable\"],\n    \"module\": \"ESNext\",\n    \"skipLibCheck\": true,\n    \"moduleResolution\": \"bundler\",\n    \"allowImportingTsExtensions\": true,\n    \"resolveJsonModule\": true,\n    \"isolatedModules\": true,\n    \"noEmit\": true,\n    \"jsx\": \"react-jsx\",\n    \"strict\": true,\n    \"noUnusedLocals\": true,\n    \"noUnusedParameters\": true,\n    \"noFallthroughCasesInSwitch\": true,\n    \"declaration\": true,\n    \"declarationMap\": true,\n    \"outDir\": \"dist\"\n  },\n  \"include\": [\"src\"],\n  \"references\": [{ \"path\": \"./tsconfig.node.json\" }]\n}\n```\n\n## Main exports\n\n```ts\n// src/index.ts\n// Components\nexport { Button } from './components/Button';\nexport type { ButtonProps } from './components/Button';\n\nexport { Card } from './components/Card';\nexport type { CardProps } from './components/Card';\n\nexport { Input } from './components/Input';\nexport type { InputProps } from './components/Input';\n\n// Theme\nexport { ThemeProvider, useTheme } from './components/ThemeProvider';\nexport { darkTheme, highContrastTheme } from './tokens/themes';\n\n// Tokens (for custom styling)\nexport { colors, semanticColors, spacing, fontSize, fontWeight, lineHeight } from './tokens';\n```\n\n## Usage examples\n\n### Installation\n\n```bash\nnpm install @myorg/ui-library typestyles react react-dom\n```\n\n### Basic usage\n\n```tsx\nimport { Button, Card, Input } from '@myorg/ui-library';\n\nfunction App() {\n  return (\n    <Card>\n      <Card.Header>\n        <h2>Login</h2>\n      </Card.Header>\n      <Card.Body>\n        <Input label=\"Email\" type=\"email\" />\n        <Input label=\"Password\" type=\"password\" />\n      </Card.Body>\n      <Card.Footer>\n        <Button variant=\"primary\" fullWidth>\n          Sign In\n        </Button>\n      </Card.Footer>\n    </Card>\n  );\n}\n```\n\n### With theming\n\n```tsx\nimport { ThemeProvider, Button } from '@myorg/ui-library';\n\nfunction App() {\n  return (\n    <ThemeProvider defaultTheme=\"dark\">\n      <Button variant=\"primary\">I adapt to the theme!</Button>\n    </ThemeProvider>\n  );\n}\n```\n\n### Using tokens for custom styling\n\n```tsx\nimport { Button } from '@myorg/ui-library';\nimport { semanticColors, spacing } from '@myorg/ui-library/tokens';\nimport { styles } from 'typestyles';\n\nconst customCard = styles.create('custom-card', {\n  base: {\n    padding: spacing[6],\n    border: `2px solid ${semanticColors.primary}`,\n    borderRadius: '12px',\n  },\n});\n\nfunction CustomComponent() {\n  return (\n    <div className={customCard('base')}>\n      <Button variant=\"primary\">Library Button</Button>\n    </div>\n  );\n}\n```\n\n## Publishing\n\n### Build the library\n\n```bash\nnpm run build\n```\n\n### Publish to npm\n\n```bash\nnpm login\nnpm publish --access public\n```\n\n## Versioning\n\nFollow semantic versioning:\n\n- **Patch (1.0.1)**: Bug fixes, token value changes\n- **Minor (1.1.0)**: New components, new tokens (backward compatible)\n- **Major (2.0.0)**: Breaking changes, removed components, renamed tokens\n\n## Best practices\n\n1. **Export prop types** - Let consumers extend your components\n2. **Document breaking changes** - Keep a detailed changelog\n3. **Test thoroughly** - Components should work in any React app\n4. **Minimize dependencies** - Keep the library lightweight\n5. **Provide examples** - Show how to customize and extend\n6. **Support tree-shaking** - Use ES modules and avoid side effects\n7. **Version tokens separately** - Consider a separate tokens package\n8. **Test with multiple React versions** - Ensure compatibility\n\n## Troubleshooting\n\n### Styles not working in consumer app\n\nMake sure `typestyles` is installed in the consumer app:\n\n```bash\nnpm install typestyles\n```\n\n### TypeScript errors in consumer\n\nEnsure the consumer has compatible TypeScript settings:\n\n```json\n{\n  \"compilerOptions\": {\n    \"moduleResolution\": \"bundler\",\n    \"esModuleInterop\": true\n  }\n}\n```\n\n### Duplicate typestyles instances\n\nIf you see duplicate style tags, ensure `typestyles` is a peer dependency, not a regular dependency.\n",
    "title": "Component Library Setup",
    "description": "Building a reusable component library with typestyles",
    "_meta": {
      "filePath": "component-library.md",
      "fileName": "component-library.md",
      "directory": ".",
      "extension": "md",
      "path": "component-library"
    }
  },
  {
    "content": "\n# Custom Selectors & At-Rules\n\nTypeStyles supports all CSS at-rules and advanced selectors through special key prefixes.\n\n## Pseudo-classes and pseudo-elements\n\nUse the `&` prefix for pseudo-classes:\n\n```ts\nconst button = styles.create('button', {\n  base: {\n    padding: '8px 16px',\n    backgroundColor: '#0066ff',\n    color: 'white',\n\n    // Hover state\n    '&:hover': {\n      backgroundColor: '#0052cc',\n    },\n\n    // Focus state\n    '&:focus': {\n      outline: '2px solid #0066ff',\n      outlineOffset: '2px',\n    },\n\n    // Active/pressed state\n    '&:active': {\n      transform: 'scale(0.98)',\n    },\n\n    // Disabled state\n    '&:disabled': {\n      opacity: 0.5,\n      cursor: 'not-allowed',\n    },\n\n    // Pseudo-elements\n    '&::before': {\n      content: '\"\"',\n      display: 'inline-block',\n      width: '16px',\n      height: '16px',\n    },\n\n    '&::after': {\n      content: '\" →\"',\n    },\n  },\n});\n```\n\n### Form-related pseudo-classes\n\n```ts\nconst input = styles.create('input', {\n  base: {\n    border: '1px solid #e5e7eb',\n\n    // Checked state (checkboxes, radios)\n    '&:checked': {\n      backgroundColor: '#0066ff',\n    },\n\n    // Placeholder text\n    '&::placeholder': {\n      color: '#9ca3af',\n    },\n\n    // Invalid state\n    '&:invalid': {\n      borderColor: '#ef4444',\n    },\n\n    // Valid state\n    '&:valid': {\n      borderColor: '#10b981',\n    },\n\n    // Required field\n    '&:required': {\n      borderColor: '#f59e0b',\n    },\n  },\n});\n```\n\n### Structural pseudo-classes\n\n```ts\nconst list = styles.create('list', {\n  item: {\n    padding: '8px 0',\n    borderBottom: '1px solid #e5e7eb',\n\n    // First child\n    '&:first-child': {\n      paddingTop: 0,\n    },\n\n    // Last child\n    '&:last-child': {\n      paddingBottom: 0,\n      borderBottom: 'none',\n    },\n\n    // Every other item\n    '&:nth-child(even)': {\n      backgroundColor: '#f9fafb',\n    },\n\n    // First 3 items\n    '&:nth-child(-n+3)': {\n      fontWeight: 600,\n    },\n\n    // Only child\n    '&:only-child': {\n      border: 'none',\n    },\n  },\n});\n```\n\n## Descendant and sibling selectors\n\n### Child selectors\n\n```ts\nconst card = styles.create('card', {\n  base: {\n    padding: '16px',\n  },\n\n  // Direct children\n  '& > header': {\n    marginBottom: '12px',\n    fontWeight: 600,\n  },\n\n  // Any descendant\n  '& .content': {\n    lineHeight: 1.6,\n  },\n\n  // Descendant with specific element\n  '& p': {\n    marginBottom: '8px',\n  },\n\n  // Multiple selectors\n  '& h1, & h2, & h3': {\n    marginTop: 0,\n  },\n});\n```\n\n### Sibling selectors\n\n```ts\nconst form = styles.create('form', {\n  base: {\n    display: 'flex',\n    flexDirection: 'column',\n    gap: '16px',\n  },\n\n  // Adjacent sibling\n  '& > * + *': {\n    // Adds margin between consecutive children (owl selector)\n    marginTop: '16px',\n  },\n\n  // General sibling\n  '& input ~ .error': {\n    display: 'none',\n  },\n\n  '& input:invalid ~ .error': {\n    display: 'block',\n    color: '#ef4444',\n  },\n});\n```\n\n## Attribute selectors\n\n```ts\nconst link = styles.create('link', {\n  base: {\n    color: '#0066ff',\n    textDecoration: 'none',\n\n    // External links\n    '&[href^=\"http\"]': {\n      '&::after': {\n        content: '\" ↗\"',\n      },\n    },\n\n    // Download links\n    '&[download]': {\n      '&::after': {\n        content: '\" ↓\"',\n      },\n    },\n\n    // Links with specific target\n    '&[target=\"_blank\"]': {\n      '&::after': {\n        content: '\" (opens in new tab)\"',\n      },\n    },\n  },\n});\n```\n\n## Media queries\n\nUse the `@` prefix for media queries:\n\n```ts\nconst layout = styles.create('layout', {\n  container: {\n    display: 'grid',\n    gridTemplateColumns: '1fr',\n    gap: '16px',\n\n    // Tablet\n    '@media (min-width: 768px)': {\n      gridTemplateColumns: 'repeat(2, 1fr)',\n    },\n\n    // Desktop\n    '@media (min-width: 1024px)': {\n      gridTemplateColumns: 'repeat(3, 1fr)',\n    },\n\n    // Wide screens\n    '@media (min-width: 1440px)': {\n      gridTemplateColumns: 'repeat(4, 1fr)',\n      gap: '24px',\n    },\n  },\n});\n```\n\n### Complex media queries\n\n```ts\nconst hero = styles.create('hero', {\n  base: {\n    padding: '48px 16px',\n\n    // High DPI screens\n    '@media (min-resolution: 192dpi)': {\n      backgroundImage: 'url(hero@2x.jpg)',\n    },\n\n    // Dark mode preference\n    '@media (prefers-color-scheme: dark)': {\n      backgroundColor: '#1a1a2e',\n      color: '#e0e0e0',\n    },\n\n    // Reduced motion preference\n    '@media (prefers-reduced-motion: reduce)': {\n      animation: 'none',\n      transition: 'none',\n    },\n\n    // Print styles\n    '@media print': {\n      background: 'none',\n      color: 'black',\n    },\n  },\n});\n```\n\n### Combining media queries with pseudo-classes\n\n```ts\nconst button = styles.create('button', {\n  base: {\n    padding: '8px 16px',\n\n    // Hover only on devices that support it\n    '@media (hover: hover)': {\n      '&:hover': {\n        backgroundColor: '#0052cc',\n      },\n    },\n\n    // Touch device adjustments\n    '@media (pointer: coarse)': {\n      padding: '12px 20px', // Larger touch target\n    },\n  },\n});\n```\n\n## Container queries\n\nContainer queries respond to the size of a container, not the viewport:\n\n```ts\nconst card = styles.create('card', {\n  base: {\n    // Establish this element as a container\n    containerType: 'inline-size',\n    containerName: 'card',\n  },\n\n  content: {\n    padding: '12px',\n\n    // When container is at least 400px wide\n    '@container (min-width: 400px)': {\n      padding: '24px',\n      display: 'flex',\n      gap: '16px',\n    },\n\n    // When container is at least 600px wide\n    '@container (min-width: 600px)': {\n      padding: '32px',\n    },\n  },\n});\n```\n\n### Named container queries\n\n```ts\nconst sidebar = styles.create('sidebar', {\n  base: {\n    containerName: 'sidebar',\n    containerType: 'inline-size',\n    width: '280px',\n  },\n\n  content: {\n    // Styles that respond to sidebar width\n    '@container sidebar (min-width: 250px)': {\n      display: 'block',\n    },\n  },\n});\n```\n\n## Supports queries\n\nFeature detection with `@supports`:\n\n```ts\nconst backdrop = styles.create('backdrop', {\n  base: {\n    backgroundColor: 'rgba(0, 0, 0, 0.5)',\n\n    // Use backdrop-filter if supported\n    '@supports (backdrop-filter: blur(4px))': {\n      backdropFilter: 'blur(4px)',\n      backgroundColor: 'rgba(0, 0, 0, 0.3)',\n    },\n  },\n});\n```\n\n### Complex supports queries\n\n```ts\nconst grid = styles.create('grid', {\n  base: {\n    // Fallback layout\n    display: 'flex',\n    flexWrap: 'wrap',\n\n    // Use grid if supported\n    '@supports (display: grid)': {\n      display: 'grid',\n      gridTemplateColumns: 'repeat(auto-fit, minmax(250px, 1fr))',\n    },\n\n    // Use subgrid if supported\n    '@supports (grid-template-columns: subgrid)': {\n      gridTemplateColumns: 'subgrid',\n    },\n  },\n});\n```\n\n## Layer (cascade layers)\n\nCSS cascade layers for organizing styles:\n\n```ts\nconst reset = styles.create('reset', {\n  base: {\n    // Apply to @layer reset\n    '@layer reset': {\n      margin: 0,\n      padding: 0,\n      boxSizing: 'border-box',\n    },\n  },\n});\n\nconst components = styles.create('components', {\n  button: {\n    '@layer components': {\n      padding: '8px 16px',\n      backgroundColor: '#0066ff',\n    },\n  },\n});\n```\n\n## Nesting depth\n\nWhile typestyles supports deep nesting, it's best to keep it shallow:\n\n```ts\n// ✅ Good - 2-3 levels deep\nconst nav = styles.create('nav', {\n  base: {\n    display: 'flex',\n\n    '& li': {\n      position: 'relative',\n\n      '&:hover > ul': {\n        display: 'block', // 3 levels, acceptable\n      },\n    },\n  },\n});\n\n// ❌ Avoid - too deep, hard to maintain\nconst deep = styles.create('deep', {\n  base: {\n    '& div': {\n      '& span': {\n        '& a': {\n          '&:hover': {\n            color: 'red', // 5 levels, problematic\n          },\n        },\n      },\n    },\n  },\n});\n```\n\n## Complex real-world example\n\n```ts\nconst dataTable = styles.create('data-table', {\n  container: {\n    overflowX: 'auto',\n    containerType: 'inline-size',\n    containerName: 'data-table',\n  },\n\n  table: {\n    width: '100%',\n    borderCollapse: 'collapse',\n\n    // Responsive adjustments\n    '@container (max-width: 600px)': {\n      fontSize: '14px',\n    },\n\n    // Sticky header\n    '& thead': {\n      position: 'sticky',\n      top: 0,\n      backgroundColor: '#f9fafb',\n\n      '& th': {\n        padding: '12px',\n        textAlign: 'left',\n        fontWeight: 600,\n\n        '&:hover': {\n          backgroundColor: '#e5e7eb',\n          cursor: 'pointer',\n        },\n      },\n    },\n\n    // Body rows\n    '& tbody tr': {\n      borderBottom: '1px solid #e5e7eb',\n\n      '&:last-child': {\n        borderBottom: 'none',\n      },\n\n      '&:hover': {\n        backgroundColor: '#f9fafb',\n      },\n\n      '& td': {\n        padding: '12px',\n      },\n\n      // Selected row\n      '&[data-selected=\"true\"]': {\n        backgroundColor: '#eff6ff',\n      },\n    },\n  },\n\n  // Print styles\n  '@media print': {\n    container: {\n      overflow: 'visible',\n    },\n\n    table: {\n      '& thead': {\n        position: 'static',\n      },\n    },\n  },\n});\n```\n\n## Generated CSS\n\nTypeStyles converts these nested objects to flat CSS:\n\n**Input:**\n\n```ts\nconst button = styles.create('button', {\n  base: {\n    padding: '8px',\n    '&:hover': {\n      backgroundColor: 'blue',\n    },\n    '@media (min-width: 768px)': {\n      padding: '12px',\n    },\n  },\n});\n```\n\n**Generated CSS:**\n\n```css\n.button-base {\n  padding: 8px;\n}\n\n.button-base:hover {\n  background-color: blue;\n}\n\n@media (min-width: 768px) {\n  .button-base {\n    padding: 12px;\n  }\n}\n```\n\n## Best practices\n\n1. **Keep nesting shallow** - Max 3 levels deep\n2. **Use container queries** - For component-level responsiveness\n3. **Use media queries** - For viewport-level changes\n4. **Combine selectors wisely** - Avoid overly complex selectors\n5. **Test in real browsers** - Some selectors have varying support\n6. **Consider progressive enhancement** - Use `@supports` for new features\n",
    "title": "Custom Selectors & At-Rules",
    "description": "Using @container, @supports, and other CSS features",
    "_meta": {
      "filePath": "custom-at-rules.md",
      "fileName": "custom-at-rules.md",
      "directory": ".",
      "extension": "md",
      "path": "custom-at-rules"
    }
  },
  {
    "content": "\n# Design System with Tokens\n\nA design system is more than just components—it's a complete set of standards for design and code. This guide shows how to build a token-based design system with typestyles.\n\n## Token architecture\n\n### Three-layer token system\n\n```\nLayer 1: Primitives (raw values)\n    ↓\nLayer 2: Semantics (meaningful tokens)\n    ↓\nLayer 3: Components (component-specific)\n```\n\n### Layer 1: Primitives\n\nRaw values from your brand guidelines:\n\n```ts\n// tokens/primitives/colors.ts\nexport const primitiveColors = {\n  // Brand palette\n  brand: {\n    50: '#eff6ff',\n    100: '#dbeafe',\n    200: '#bfdbfe',\n    300: '#93c5fd',\n    400: '#60a5fa',\n    500: '#3b82f6',\n    600: '#2563eb',\n    700: '#1d4ed8',\n    800: '#1e40af',\n    900: '#1e3a8a',\n  },\n\n  // Neutral palette\n  gray: {\n    50: '#f9fafb',\n    100: '#f3f4f6',\n    200: '#e5e7eb',\n    300: '#d1d5db',\n    400: '#9ca3af',\n    500: '#6b7280',\n    600: '#4b5563',\n    700: '#374151',\n    800: '#1f2937',\n    900: '#111827',\n    950: '#030712',\n  },\n\n  // Functional colors\n  red: { 50: '#fef2f2', 500: '#ef4444', 900: '#7f1d1d' },\n  orange: { 50: '#fff7ed', 500: '#f97316', 900: '#7c2d12' },\n  yellow: { 50: '#fefce8', 500: '#eab308', 900: '#713f12' },\n  green: { 50: '#f0fdf4', 500: '#22c55e', 900: '#14532d' },\n  blue: { 50: '#eff6ff', 500: '#3b82f6', 900: '#1e3a8a' },\n  purple: { 50: '#faf5ff', 500: '#a855f7', 900: '#581c87' },\n} as const;\n```\n\n```ts\n// tokens/primitives/spacing.ts\nexport const primitiveSpacing = {\n  0: '0px',\n  1: '4px',\n  2: '8px',\n  3: '12px',\n  4: '16px',\n  5: '20px',\n  6: '24px',\n  8: '32px',\n  10: '40px',\n  12: '48px',\n  16: '64px',\n  20: '80px',\n  24: '96px',\n  32: '128px',\n  40: '160px',\n  48: '192px',\n  56: '224px',\n  64: '256px',\n} as const;\n```\n\n```ts\n// tokens/primitives/typography.ts\nexport const primitiveTypography = {\n  fontFamily: {\n    sans: ['Inter', 'system-ui', 'sans-serif'],\n    serif: ['Georgia', 'Cambria', 'serif'],\n    mono: ['Menlo', 'Monaco', 'monospace'],\n  },\n  fontSize: {\n    xs: '0.75rem', // 12px\n    sm: '0.875rem', // 14px\n    base: '1rem', // 16px\n    lg: '1.125rem', // 18px\n    xl: '1.25rem', // 20px\n    '2xl': '1.5rem', // 24px\n    '3xl': '1.875rem', // 30px\n    '4xl': '2.25rem', // 36px\n    '5xl': '3rem', // 48px\n    '6xl': '3.75rem', // 60px\n    '7xl': '4.5rem', // 72px\n  },\n  fontWeight: {\n    thin: '100',\n    light: '300',\n    normal: '400',\n    medium: '500',\n    semibold: '600',\n    bold: '700',\n    extrabold: '800',\n    black: '900',\n  },\n  lineHeight: {\n    none: '1',\n    tight: '1.25',\n    snug: '1.375',\n    normal: '1.5',\n    relaxed: '1.625',\n    loose: '2',\n  },\n  letterSpacing: {\n    tighter: '-0.05em',\n    tight: '-0.025em',\n    normal: '0',\n    wide: '0.025em',\n    wider: '0.05em',\n    widest: '0.1em',\n  },\n} as const;\n```\n\n### Layer 2: Semantic tokens\n\nMeaningful tokens that reference primitives:\n\n```ts\n// tokens/semantic/colors.ts\nimport { tokens } from 'typestyles';\nimport { primitiveColors } from '../primitives/colors';\n\nexport const color = tokens.create('color', {\n  // Brand\n  brand: primitiveColors.brand[500],\n  brandHover: primitiveColors.brand[600],\n  brandActive: primitiveColors.brand[700],\n  brandSubtle: primitiveColors.brand[100],\n  brandMuted: primitiveColors.brand[200],\n\n  // Text\n  text: primitiveColors.gray[900],\n  textMuted: primitiveColors.gray[500],\n  textSubtle: primitiveColors.gray[400],\n  textInverse: '#ffffff',\n  textBrand: primitiveColors.brand[600],\n\n  // Backgrounds\n  background: primitiveColors.gray[50],\n  surface: '#ffffff',\n  surfaceRaised: primitiveColors.gray[100],\n  surfaceSunken: primitiveColors.gray[50],\n  surfaceOverlay: 'rgba(0, 0, 0, 0.5)',\n\n  // Borders\n  border: primitiveColors.gray[200],\n  borderHover: primitiveColors.gray[300],\n  borderActive: primitiveColors.brand[500],\n\n  // Status\n  success: primitiveColors.green[500],\n  successSubtle: primitiveColors.green[50],\n  warning: primitiveColors.orange[500],\n  warningSubtle: primitiveColors.orange[50],\n  danger: primitiveColors.red[500],\n  dangerSubtle: primitiveColors.red[50],\n  info: primitiveColors.blue[500],\n  infoSubtle: primitiveColors.blue[50],\n});\n```\n\n```ts\n// tokens/semantic/spacing.ts\nimport { tokens } from 'typestyles';\nimport { primitiveSpacing } from '../primitives/spacing';\n\nexport const space = tokens.create('space', {\n  // Base scale\n  ...primitiveSpacing,\n\n  // Semantic aliases\n  gap: primitiveSpacing[4],\n  gapSm: primitiveSpacing[2],\n  gapLg: primitiveSpacing[6],\n\n  section: primitiveSpacing[16],\n  sectionSm: primitiveSpacing[12],\n  sectionLg: primitiveSpacing[24],\n\n  component: primitiveSpacing[4],\n  componentSm: primitiveSpacing[3],\n  componentLg: primitiveSpacing[6],\n});\n```\n\n```ts\n// tokens/semantic/typography.ts\nimport { tokens } from 'typestyles';\nimport { primitiveTypography } from '../primitives/typography';\n\nexport const font = tokens.create('font', {\n  // Family\n  sans: primitiveTypography.fontFamily.sans.join(', '),\n  serif: primitiveTypography.fontFamily.serif.join(', '),\n  mono: primitiveTypography.fontFamily.mono.join(', '),\n\n  // Size scale\n  xs: primitiveTypography.fontSize.xs,\n  sm: primitiveTypography.fontSize.sm,\n  base: primitiveTypography.fontSize.base,\n  lg: primitiveTypography.fontSize.lg,\n  xl: primitiveTypography.fontSize.xl,\n  '2xl': primitiveTypography.fontSize['2xl'],\n  '3xl': primitiveTypography.fontSize['3xl'],\n  '4xl': primitiveTypography.fontSize['4xl'],\n\n  // Semantic sizes\n  body: primitiveTypography.fontSize.base,\n  bodySm: primitiveTypography.fontSize.sm,\n  bodyLg: primitiveTypography.fontSize.lg,\n  headingSm: primitiveTypography.fontSize.xl,\n  heading: primitiveTypography.fontSize['2xl'],\n  headingLg: primitiveTypography.fontSize['3xl'],\n  headingXl: primitiveTypography.fontSize['4xl'],\n  display: primitiveTypography.fontSize['5xl'],\n  displayLg: primitiveTypography.fontSize['6xl'],\n\n  // Weight\n  normal: primitiveTypography.fontWeight.normal,\n  medium: primitiveTypography.fontWeight.medium,\n  semibold: primitiveTypography.fontWeight.semibold,\n  bold: primitiveTypography.fontWeight.bold,\n\n  // Line height\n  none: primitiveTypography.lineHeight.none,\n  tight: primitiveTypography.lineHeight.tight,\n  snug: primitiveTypography.lineHeight.snug,\n  normal: primitiveTypography.lineHeight.normal,\n  relaxed: primitiveTypography.lineHeight.relaxed,\n  loose: primitiveTypography.lineHeight.loose,\n\n  // Letter spacing\n  tighter: primitiveTypography.letterSpacing.tighter,\n  tight: primitiveTypography.letterSpacing.tight,\n  normal: primitiveTypography.letterSpacing.normal,\n  wide: primitiveTypography.letterSpacing.wide,\n  wider: primitiveTypography.letterSpacing.wider,\n  widest: primitiveTypography.letterSpacing.widest,\n});\n```\n\n### Layer 3: Component tokens\n\nComponent-specific tokens:\n\n```ts\n// tokens/components/button.ts\nimport { tokens } from 'typestyles';\nimport { color, space, font } from '../semantic';\n\nexport const button = tokens.create('button', {\n  // Size\n  heightSm: '32px',\n  heightMd: '40px',\n  heightLg: '48px',\n\n  // Padding\n  paddingHorizontalSm: space[3],\n  paddingHorizontalMd: space[4],\n  paddingHorizontalLg: space[6],\n\n  // Border radius\n  borderRadius: '6px',\n  borderRadiusSm: '4px',\n  borderRadiusLg: '8px',\n\n  // Font\n  fontSizeSm: font.sm,\n  fontSizeMd: font.base,\n  fontSizeLg: font.lg,\n  fontWeight: font.medium,\n\n  // Primary variant\n  primaryBackground: color.brand,\n  primaryBackgroundHover: color.brandHover,\n  primaryBackgroundActive: color.brandActive,\n  primaryText: color.textInverse,\n\n  // Secondary variant\n  secondaryBackground: color.surface,\n  secondaryBackgroundHover: color.surfaceRaised,\n  secondaryBorder: color.border,\n  secondaryText: color.text,\n\n  // Focus ring\n  focusRingColor: color.brand,\n  focusRingWidth: '2px',\n  focusRingOffset: '2px',\n});\n```\n\n```ts\n// tokens/components/card.ts\nimport { tokens } from 'typestyles';\nimport { color, space } from '../semantic';\n\nexport const card = tokens.create('card', {\n  // Spacing\n  padding: space[6],\n  paddingSm: space[4],\n  paddingLg: space[8],\n\n  // Visual\n  borderRadius: '8px',\n  borderWidth: '1px',\n  borderColor: color.border,\n  background: color.surface,\n\n  // Shadow\n  shadow: '0 1px 3px rgba(0, 0, 0, 0.1)',\n  shadowHover: '0 4px 6px rgba(0, 0, 0, 0.1)',\n\n  // Header\n  headerPadding: space[4],\n  headerBorderColor: color.border,\n\n  // Body\n  bodyPadding: space[6],\n\n  // Footer\n  footerPadding: space[4],\n  footerBackground: color.surfaceRaised,\n  footerBorderColor: color.border,\n});\n```\n\n## Token documentation\n\n### Token reference table\n\nCreate documentation for your tokens:\n\n```md\n# Color Tokens\n\n## Brand\n\n| Token               | Value   | Usage                  |\n| ------------------- | ------- | ---------------------- |\n| `color.brand`       | #3b82f6 | Primary buttons, links |\n| `color.brandHover`  | #2563eb | Hover states           |\n| `color.brandSubtle` | #dbeafe | Light backgrounds      |\n\n## Text\n\n| Token               | Value   | Usage                    |\n| ------------------- | ------- | ------------------------ |\n| `color.text`        | #111827 | Primary text             |\n| `color.textMuted`   | #6b7280 | Secondary text           |\n| `color.textInverse` | #ffffff | Text on dark backgrounds |\n\n## Status\n\n| Token           | Value   | Usage          |\n| --------------- | ------- | -------------- |\n| `color.success` | #22c55e | Success states |\n| `color.danger`  | #ef4444 | Error states   |\n```\n\n### Token usage examples\n\n```ts\n// Always use tokens, never hardcode values\n\n// ❌ Bad\nconst button = styles.create('button', {\n  base: {\n    padding: '8px 16px', // Hardcoded\n    backgroundColor: '#3b82f6', // Hardcoded\n  },\n});\n\n// ✅ Good\nconst button = styles.create('button', {\n  base: {\n    padding: `${buttonToken.paddingHorizontalMd} ${buttonToken.paddingVerticalMd}`,\n    backgroundColor: buttonToken.primaryBackground,\n  },\n});\n```\n\n## Theme variations\n\n### Dark theme\n\n```ts\n// tokens/themes/dark.ts\nimport { tokens } from 'typestyles';\nimport { primitiveColors } from '../primitives/colors';\n\nexport const darkTheme = tokens.createTheme('dark', {\n  color: {\n    brand: primitiveColors.brand[400],\n    brandHover: primitiveColors.brand[300],\n    brandActive: primitiveColors.brand[500],\n\n    text: primitiveColors.gray[100],\n    textMuted: primitiveColors.gray[400],\n    textSubtle: primitiveColors.gray[500],\n    textInverse: primitiveColors.gray[900],\n\n    background: primitiveColors.gray[900],\n    surface: primitiveColors.gray[800],\n    surfaceRaised: primitiveColors.gray[700],\n    surfaceSunken: primitiveColors.gray[950],\n\n    border: primitiveColors.gray[700],\n    borderHover: primitiveColors.gray[600],\n  },\n});\n```\n\n### High contrast theme\n\n```ts\n// tokens/themes/high-contrast.ts\nimport { tokens } from 'typestyles';\n\nexport const highContrastTheme = tokens.createTheme('high-contrast', {\n  color: {\n    text: '#000000',\n    background: '#ffffff',\n    border: '#000000',\n    brand: '#0000ff',\n\n    success: '#006600',\n    warning: '#cc6600',\n    danger: '#cc0000',\n  },\n});\n```\n\n## Token naming conventions\n\n### Consistent naming\n\n```\nCategory + Property + Variant + State\n\nExamples:\n- color.text (category.property)\n- color.textMuted (category.property.variant)\n- color.textMutedHover (category.property.variant.state)\n- button.primaryBackground (category.property)\n- button.primaryBackgroundHover (category.property.state)\n```\n\n### Property modifiers\n\n```\nBase: color.brand\nSubtle: color.brandSubtle\nMuted: color.brandMuted\nHover: color.brandHover\nActive: color.brandActive\nDisabled: color.brandDisabled\nInverse: color.brandInverse\n```\n\n## Token validation\n\n### Type checking\n\n```ts\n// Ensure all required tokens exist\ninterface RequiredTokens {\n  brand: string;\n  text: string;\n  background: string;\n  // ... etc\n}\n\n// TypeScript will catch missing tokens\nconst requiredTokens: RequiredTokens = {\n  brand: color.brand,\n  text: color.text,\n  background: color.background,\n};\n```\n\n### Contrast checking\n\n```ts\n// WCAG contrast ratio helper\nfunction getContrastRatio(color1: string, color2: string): number {\n  // Implementation\n}\n\n// Ensure accessible contrast\nconst contrastRatio = getContrastRatio(color.text, color.background);\nif (contrastRatio < 4.5) {\n  console.warn('Text contrast does not meet WCAG AA standards');\n}\n```\n\n## Token distribution\n\n### NPM package structure\n\n```\n@myorg/design-tokens/\n├── package.json\n├── tokens/\n│   ├── primitives/\n│   ├── semantic/\n│   ├── components/\n│   └── themes/\n└── dist/\n    ├── tokens.css      # CSS custom properties\n    ├── tokens.json     # JSON format\n    └── tokens.scss     # SCSS variables\n```\n\n### Multiple formats\n\n```ts\n// Build script to generate multiple formats\nimport { tokens } from './tokens';\n\n// CSS custom properties\nconst css = generateCSS(tokens);\n\n// SCSS variables\nconst scss = generateSCSS(tokens);\n\n// JSON\nconst json = JSON.stringify(tokens, null, 2);\n\n// Write to files\nfs.writeFileSync('dist/tokens.css', css);\nfs.writeFileSync('dist/tokens.scss', scss);\nfs.writeFileSync('dist/tokens.json', json);\n```\n\n## Token governance\n\n### Change process\n\n1. **Request**: Designer/developer requests a new token\n2. **Review**: Design system team reviews for necessity\n3. **Naming**: Follow naming conventions\n4. **Documentation**: Update token reference\n5. **Communication**: Announce breaking changes\n6. **Deprecation**: Mark old tokens as deprecated before removal\n\n### Versioning\n\n```json\n{\n  \"name\": \"@myorg/design-tokens\",\n  \"version\": \"2.1.0\",\n  \"description\": \"Design tokens for the Acme design system\"\n}\n```\n\nBreaking changes (new major version):\n\n- Removing tokens\n- Renaming tokens\n- Changing token values significantly\n\nNon-breaking changes (new minor/patch):\n\n- Adding new tokens\n- Small value adjustments\n- Adding new themes\n\n## Best practices summary\n\n1. **Never hardcode values** - Always use tokens\n2. **Use semantic names** - `color.text` not `color.gray900`\n3. **Layer your tokens** - Primitives → Semantics → Components\n4. **Document everything** - Maintain token reference\n5. **Test contrast** - Ensure accessibility compliance\n6. **Version carefully** - Follow semantic versioning\n7. **Support multiple themes** - Light, dark, high-contrast\n8. **Generate multiple formats** - CSS, SCSS, JSON for different consumers\n9. **Govern changes** - Have a process for token modifications\n10. **Provide examples** - Show developers how to use tokens\n",
    "title": "Design System with Tokens",
    "description": "Building a comprehensive design system using typestyles tokens",
    "_meta": {
      "filePath": "design-system.md",
      "fileName": "design-system.md",
      "directory": ".",
      "extension": "md",
      "path": "design-system"
    }
  },
  {
    "content": "\n# Getting Started\n\ntypestyles is **CSS-in-TypeScript** that embraces CSS instead of hiding from it. You define styles and tokens in TypeScript and get predictable, scoped class names and design tokens as CSS custom properties.\n\n## Installation\n\n```bash\npnpm add typestyles\n# or\nnpm install typestyles\n```\n\n## Basic usage\n\nCreate styles with `styles.create()` and apply them with the returned selector function:\n\n```ts\nimport { styles } from 'typestyles';\n\nconst button = styles.create('button', {\n  base: { padding: '8px 16px', borderRadius: '6px' },\n  primary: { backgroundColor: '#0066ff', color: '#fff' },\n});\n\n// In your component: className={button('base', 'primary')}\n```\n\nCreate design tokens with `tokens.create()` and use them in styles:\n\n```ts\nimport { tokens } from 'typestyles';\n\nconst color = tokens.create('color', {\n  primary: '#0066ff',\n});\n\n// Use in styles: backgroundColor: color.primary\n// Renders as: var(--color-primary)\n```\n\nYou stay in control of the CSS; typestyles just generates the class names and custom properties.\n",
    "title": "Getting Started",
    "description": "Install and use typestyles in your project",
    "_meta": {
      "filePath": "getting-started.md",
      "fileName": "getting-started.md",
      "directory": ".",
      "extension": "md",
      "path": "getting-started"
    }
  },
  {
    "content": "\n# Keyframes\n\nThe `keyframes` API lets you define CSS animations with type-safe keyframe stops. Like styles and tokens, keyframes generate readable names and integrate seamlessly with the rest of your typestyles.\n\n## Creating animations\n\nUse `keyframes.create(name, stops)` to define an animation:\n\n```ts\nimport { keyframes } from 'typestyles';\n\nconst fadeIn = keyframes.create('fadeIn', {\n  from: { opacity: 0 },\n  to: { opacity: 1 },\n});\n```\n\nThe function returns the animation name as a string, which you can use directly in your styles:\n\n```ts\nconst card = styles.create('card', {\n  base: {\n    animation: `${fadeIn} 300ms ease`,\n  },\n});\n```\n\n## Keyframe stops\n\nYou can use percentage values, `from` (0%), or `to` (100%):\n\n```ts\nconst bounce = keyframes.create('bounce', {\n  '0%': { transform: 'translateY(0)' },\n  '40%': { transform: 'translateY(-30px)' },\n  '60%': { transform: 'translateY(-15px)' },\n  '100%': { transform: 'translateY(0)' },\n});\n```\n\n## Using with styles\n\nReference keyframes in your style definitions using template literals:\n\n```ts\nimport { styles, keyframes } from 'typestyles';\n\nconst spin = keyframes.create('spin', {\n  from: { transform: 'rotate(0deg)' },\n  to: { transform: 'rotate(360deg)' },\n});\n\nconst loader = styles.create('loader', {\n  base: {\n    width: '24px',\n    height: '24px',\n    border: '3px solid #e5e7eb',\n    borderTopColor: '#0066ff',\n    borderRadius: '50%',\n    animation: `${spin} 800ms linear infinite`,\n  },\n});\n```\n\n## Multiple properties\n\nEach keyframe stop can contain multiple CSS properties:\n\n```ts\nconst slideIn = keyframes.create('slideIn', {\n  from: {\n    opacity: 0,\n    transform: 'translateX(-20px)',\n  },\n  to: {\n    opacity: 1,\n    transform: 'translateX(0)',\n  },\n});\n```\n\n## TypeScript support\n\nKeyframe stops are fully typed, giving you autocomplete and error checking:\n\n```ts\n// TypeScript will catch this typo\nconst badAnimation = keyframes.create('bad', {\n  frrom: { opacity: 0 }, // Error: Object literal may only specify known properties\n  to: { opacity: 1 },\n});\n```\n\n## Generated CSS\n\nKeyframes generate standard CSS `@keyframes` rules with the exact name you provide:\n\n```css\n@keyframes fadeIn {\n  from {\n    opacity: 0;\n  }\n  to {\n    opacity: 1;\n  }\n}\n\n@keyframes bounce {\n  0% {\n    transform: translateY(0);\n  }\n  40% {\n    transform: translateY(-30px);\n  }\n  60% {\n    transform: translateY(-15px);\n  }\n  100% {\n    transform: translateY(0);\n  }\n}\n```\n\nThis makes debugging easy—you'll see `fadeIn` in DevTools, not a hashed string.\n\n## Performance note\n\nKeyframe CSS is injected once when the animation is first used, just like styles. Multiple components using the same animation share the same CSS rule.\n",
    "title": "Keyframes",
    "description": "Create CSS animations with type-safe keyframe definitions",
    "_meta": {
      "filePath": "keyframes.md",
      "fileName": "keyframes.md",
      "directory": ".",
      "extension": "md",
      "path": "keyframes"
    }
  },
  {
    "content": "\n# Migration Guide\n\nSwitching to typestyles from other styling solutions is straightforward. This guide covers the most common migration paths.\n\n## From styled-components\n\n### Component structure\n\n**Before (styled-components):**\n\n```tsx\nimport styled from 'styled-components';\n\nconst Button = styled.button`\n  padding: 8px 16px;\n  border-radius: 6px;\n  background-color: ${(props) => (props.primary ? '#0066ff' : '#6b7280')};\n  color: white;\n\n  &:hover {\n    opacity: 0.9;\n  }\n\n  &:disabled {\n    opacity: 0.5;\n    cursor: not-allowed;\n  }\n`;\n\n<Button primary>Click me</Button>;\n```\n\n**After (typestyles):**\n\n```tsx\nimport { styles, tokens } from 'typestyles';\n\nconst color = tokens.use('color');\n\nconst button = styles.create('button', {\n  base: {\n    padding: '8px 16px',\n    borderRadius: '6px',\n    color: 'white',\n    '&:hover': { opacity: 0.9 },\n    '&:disabled': { opacity: 0.5, cursor: 'not-allowed' },\n  },\n  primary: {\n    backgroundColor: color.primary,\n  },\n  secondary: {\n    backgroundColor: color.secondary,\n  },\n});\n\nfunction Button({ primary, children }) {\n  return <button className={button('base', primary && 'primary')}>{children}</button>;\n}\n```\n\n### Key differences\n\n1. **No component wrapper** - typestyles returns class names, not React components\n2. **Explicit props handling** - Logic moves from template literals to regular JavaScript\n3. **Static styles** - Dynamic values become explicit variants or are passed via inline styles\n4. **CSS nesting** - Use `&` prefix for pseudo-classes like `&:hover`\n\n### Dynamic values\n\n**Before:**\n\n```tsx\nconst Box = styled.div`\n  width: ${(props) => props.width}px;\n  height: ${(props) => props.height}px;\n`;\n```\n\n**After:**\n\n```tsx\nconst box = styles.create('box', {\n  base: {\n    display: 'inline-block',\n  },\n});\n\nfunction Box({ width, height, children }) {\n  return (\n    <div className={box('base')} style={{ width, height }}>\n      {children}\n    </div>\n  );\n}\n```\n\nDynamic values that change frequently should use inline styles. Static styles should use typestyles variants.\n\n## From Emotion\n\nEmotion's API is similar to styled-components, so the migration path is nearly identical.\n\n### css prop\n\n**Before (Emotion):**\n\n```tsx\n/** @jsxImportSource @emotion/react */\nimport { css } from '@emotion/react';\n\nfunction Button({ children }) {\n  return (\n    <button\n      css={css`\n        padding: 8px 16px;\n        background-color: #0066ff;\n        color: white;\n        &:hover {\n          background-color: #0052cc;\n        }\n      `}\n    >\n      {children}\n    </button>\n  );\n}\n```\n\n**After (typestyles):**\n\n```tsx\nimport { styles } from 'typestyles';\n\nconst button = styles.create('button', {\n  base: {\n    padding: '8px 16px',\n    backgroundColor: '#0066ff',\n    color: 'white',\n    '&:hover': {\n      backgroundColor: '#0052cc',\n    },\n  },\n});\n\nfunction Button({ children }) {\n  return <button className={button('base')}>{children}</button>;\n}\n```\n\n### cx utility\n\n**Before:**\n\n```tsx\nimport { css, cx } from '@emotion/css';\n\nconst base = css`padding: 8px;`;\nconst primary = css`background: blue;`;\nconst large = css`font-size: 18px;`;\n\nclassName={cx(base, isPrimary && primary, isLarge && large)}\n```\n\n**After:**\n\n```tsx\nimport { styles } from 'typestyles';\n\nconst button = styles.create('button', {\n  base: { padding: '8px' },\n  primary: { backgroundColor: 'blue' },\n  large: { fontSize: '18px' },\n});\n\nclassName={button('base', isPrimary && 'primary', isLarge && 'large')}\n```\n\ntypestyles' selector function already handles conditional class names, so you don't need a separate `cx` utility.\n\n## From Tailwind CSS\n\n### Class-based to object-based\n\n**Before (Tailwind):**\n\n```tsx\nfunction Button({ primary, children }) {\n  return (\n    <button\n      className={`\n        px-4 py-2 rounded\n        font-medium transition-colors\n        ${\n          primary\n            ? 'bg-blue-600 text-white hover:bg-blue-700'\n            : 'bg-gray-200 text-gray-800 hover:bg-gray-300'\n        }\n      `}\n    >\n      {children}\n    </button>\n  );\n}\n```\n\n**After (typestyles):**\n\n```tsx\nimport { styles, tokens } from 'typestyles';\n\nconst color = tokens.create('color', {\n  primary: '#0066ff',\n  primaryHover: '#0052cc',\n  secondary: '#6b7280',\n  secondaryHover: '#4b5563',\n});\n\nconst button = styles.create('button', {\n  base: {\n    padding: '8px 16px',\n    borderRadius: '6px',\n    fontWeight: 500,\n    transition: 'background-color 150ms ease',\n  },\n  primary: {\n    backgroundColor: color.primary,\n    color: '#fff',\n    '&:hover': {\n      backgroundColor: color.primaryHover,\n    },\n  },\n  secondary: {\n    backgroundColor: color.secondary,\n    color: '#fff',\n    '&:hover': {\n      backgroundColor: color.secondaryHover,\n    },\n  },\n});\n\nfunction Button({ primary, children }) {\n  return <button className={button('base', primary ? 'primary' : 'secondary')}>{children}</button>;\n}\n```\n\n### Design tokens\n\nTailwind's configuration becomes typestyles tokens:\n\n**Before (tailwind.config.js):**\n\n```js\nmodule.exports = {\n  theme: {\n    extend: {\n      colors: {\n        primary: '#0066ff',\n        secondary: '#6b7280',\n      },\n      spacing: {\n        4: '16px',\n        6: '24px',\n      },\n    },\n  },\n};\n```\n\n**After (tokens.ts):**\n\n```ts\nimport { tokens } from 'typestyles';\n\nexport const color = tokens.create('color', {\n  primary: '#0066ff',\n  secondary: '#6b7280',\n});\n\nexport const space = tokens.create('space', {\n  4: '16px',\n  6: '24px',\n});\n```\n\n### Gradual migration\n\nYou can use Tailwind and typestyles together during migration:\n\n```tsx\nimport { styles } from 'typestyles';\n\nconst card = styles.create('card', {\n  base: {\n    // New styles with typestyles\n    boxShadow: '0 4px 6px rgba(0,0,0,0.1)',\n  },\n});\n\nfunction Card({ children }) {\n  return (\n    <div className={card('base') + ' p-4 bg-white rounded'}>\n      {/*                 ^ Tailwind classes still work */}\n      {children}\n    </div>\n  );\n}\n```\n\n## From CSS Modules\n\n### File organization\n\n**Before (Button.module.css):**\n\n```css\n.button {\n  padding: 8px 16px;\n  border-radius: 6px;\n}\n\n.primary {\n  background-color: #0066ff;\n  color: white;\n}\n\n.secondary {\n  background-color: #6b7280;\n  color: white;\n}\n```\n\n**Before (Button.tsx):**\n\n```tsx\nimport styles from './Button.module.css';\n\nfunction Button({ variant, children }) {\n  return <button className={`${styles.button} ${styles[variant]}`}>{children}</button>;\n}\n```\n\n**After (button.styles.ts):**\n\n```ts\nimport { styles } from 'typestyles';\n\nexport const button = styles.create('button', {\n  base: {\n    padding: '8px 16px',\n    borderRadius: '6px',\n  },\n  primary: {\n    backgroundColor: '#0066ff',\n    color: 'white',\n  },\n  secondary: {\n    backgroundColor: '#6b7280',\n    color: 'white',\n  },\n});\n```\n\n**After (Button.tsx):**\n\n```tsx\nimport { button } from './button.styles';\n\nfunction Button({ variant, children }) {\n  return <button className={button('base', variant)}>{children}</button>;\n}\n```\n\n### Global styles\n\nCSS Modules `:global` becomes typestyles without nesting:\n\n**Before:**\n\n```css\n:global(.tooltip) {\n  position: absolute;\n}\n```\n\n**After:**\n\n```ts\nconst tooltip = styles.create('tooltip', {\n  base: {\n    position: 'absolute',\n  },\n});\n\n// Use: tooltip('base')\n```\n\n## From plain CSS\n\nMigrating from plain CSS gives you type safety and better organization.\n\n### Step-by-step\n\n1. **Identify components** - Start with your most reused components (buttons, inputs, cards)\n\n2. **Extract tokens** - Move hardcoded values to tokens:\n\n   ```ts\n   // Before: colors scattered in CSS files\n   // After:\n   export const color = tokens.create('color', {\n     primary: '#0066ff',\n     secondary: '#6b7280',\n   });\n   ```\n\n3. **Create style definitions** - Convert CSS rules to typestyles:\n\n   ```css\n   /* Before */\n   .btn {\n     padding: 8px 16px;\n     background: #0066ff;\n   }\n   .btn:hover {\n     background: #0052cc;\n   }\n   ```\n\n   ```ts\n   // After\n   const button = styles.create('button', {\n     base: {\n       padding: '8px 16px',\n       backgroundColor: color.primary,\n       '&:hover': {\n         backgroundColor: color.primaryHover,\n       },\n     },\n   });\n   ```\n\n4. **Update components** - Replace className strings with selector calls\n\n5. **Remove old CSS** - Once fully migrated, delete the CSS files\n\n## General migration tips\n\n### 1. Start small\n\nDon't migrate everything at once. Pick one component or one page and convert it. typestyles works alongside your existing styles during the transition.\n\n### 2. Keep the same names\n\nIf you have `.button-primary` in CSS, create a `button` style with a `primary` variant. This makes the migration easier to follow.\n\n### 3. Use tokens early\n\nDefine your design tokens before converting components. This ensures consistency and makes the component migration smoother.\n\n### 4. Test class names\n\nIn your tests, you may need to update selectors:\n\n**Before:**\n\n```ts\nexpect(screen.getByRole('button')).toHaveClass('button-primary');\n```\n\n**After:**\n\n```ts\nexpect(screen.getByRole('button')).toHaveClass('button-base', 'button-primary');\n```\n\n### 5. DevTools familiarity\n\nYour generated class names will be human-readable (`button-primary`), so DevTools inspection stays familiar—actually more readable than hashed class names from other CSS-in-JS libraries.\n\n### 6. Bundle size check\n\nAfter migration, your JavaScript bundle may be slightly smaller (no CSS parsing runtime) but you'll have a small runtime addition from typestyles itself. Overall size should be similar or smaller.\n\n## Common patterns comparison\n\n| Pattern            | styled-components            | Emotion                   | Tailwind            | typestyles            |\n| ------------------ | ---------------------------- | ------------------------- | ------------------- | --------------------- |\n| **Basic styling**  | `styled.div`...`             | `css`...`                 | `className=\"p-4\"`   | `styles.create()`     |\n| **Variants**       | Props + template literals    | Props + template literals | Conditional strings | Multiple variant args |\n| **Pseudo-classes** | `&:hover` in template        | `&:hover` in template     | `hover:` prefix     | `&hover` in object    |\n| **Media queries**  | `@media` in template         | `@media` in template      | Responsive prefixes | `@media` in object    |\n| **Theme values**   | `${props => props.theme...}` | `${theme...}`             | Config-based        | Token references      |\n| **Dynamic values** | Template literals            | Template literals         | Arbitrary values    | Inline styles         |\n\n## Troubleshooting migration issues\n\n### Styles not applying\n\n- Check that the namespace in `styles.create()` is unique\n- Verify the component is being rendered (lazy injection means CSS only appears when used)\n- Use DevTools to confirm class names are being applied\n\n### Type errors\n\n- Ensure you're importing from `'typestyles'`\n- Check that TypeScript knows about the CSS property types (should work out of the box)\n- For custom properties, use type assertions: `{ ['--custom' as string]: 'value' }`\n\n### Performance concerns\n\n- Don't create styles inside components (define them at module level)\n- Use tokens instead of recreating values\n- Static styles only—dynamic values should use inline styles\n\nIf you hit any issues during migration, check the [troubleshooting guide](./troubleshooting) or [open an issue](https://github.com/yourusername/typestyles/issues).\n",
    "title": "Migration Guide",
    "description": "Migrate to typestyles from other CSS-in-JS libraries",
    "_meta": {
      "filePath": "migration.md",
      "fileName": "migration.md",
      "directory": ".",
      "extension": "md",
      "path": "migration"
    }
  },
  {
    "content": "\n# Performance\n\nTypeStyles is designed to be fast. This guide explains how it works under the hood and how to keep your apps running smoothly.\n\n## How typestyles performs\n\n### Runtime cost\n\nTypeStyles operates at runtime with minimal overhead:\n\n| Operation                            | Cost     | Frequency                 |\n| ------------------------------------ | -------- | ------------------------- |\n| `styles.create()`                    | ~0.1ms   | Once per style definition |\n| Selector function (`button('base')`) | ~0.001ms | Every render              |\n| CSS injection                        | ~0.5ms   | Once per unique rule      |\n\n**What this means:**\n\n- Creating styles is fast and happens once at module load\n- Applying styles (selector calls) is just string concatenation\n- CSS is injected lazily and only once per unique style\n\n### Memory usage\n\nTypeStyles stores:\n\n- **Style definitions**: One object per style namespace\n- **CSS rules**: One string per variant\n- **Token values**: One object per token namespace\n\nTypical memory footprint: ~50KB for a medium-sized application (hundreds of components).\n\n## Bundle size\n\n### Minified + gzipped sizes\n\n```\ntypestyles (core): ~3.2KB\ntypestyles/server: +0.8KB (SSR support)\n@typestyles/vite: +2.1KB (dev only)\n```\n\n### Comparison with alternatives\n\n| Library                | Runtime Size | Total CSS-in-JS overhead |\n| ---------------------- | ------------ | ------------------------ |\n| styled-components      | ~12KB        | ~45KB (includes parser)  |\n| Emotion                | ~7KB         | ~25KB                    |\n| Linaria (zero-runtime) | 0KB          | 0KB (build-time only)    |\n| StyleX                 | ~0KB         | ~0KB (build-time only)   |\n| **TypeStyles**         | **~3.2KB**   | **~3.2KB**               |\n\nTypeStyles sits between full runtime libraries and zero-runtime solutions.\n\n## Lazy injection\n\nStyles aren't injected until they're used. This means:\n\n```ts\n// This is defined but no CSS is injected yet\nconst button = styles.create('button', {\n  base: { padding: '8px' },\n});\n\n// CSS is only injected when the component renders\nfunction App() {\n  return <button className={button('base')}>Click</button>;\n}\n```\n\n**Benefits:**\n\n- Unused code paths don't add CSS weight\n- Initial page load is faster\n- Code-split styles work automatically\n\n## Batched DOM updates\n\nCSS rules are batched and inserted on the next frame:\n\n```ts\n// Multiple style definitions\nconst button = styles.create('button', { ... });\nconst card = styles.create('card', { ... });\nconst input = styles.create('input', { ... });\n\n// All queued together, inserted in one operation\n// Uses requestAnimationFrame or microtask for batching\n```\n\n**Benefits:**\n\n- Fewer DOM manipulations\n- Better performance during initial render\n- Avoids forced synchronous layout\n\n## Performance best practices\n\n### 1. Define styles at module level\n\n```ts\n// ✅ Good - defined once\nconst button = styles.create('button', { ... });\n\nfunction Button() {\n  return <button className={button('base')} />;\n}\n\n// ❌ Bad - redefined on every render\nfunction Button() {\n  const button = styles.create('button', { ... }); // Don't do this!\n  return <button className={button('base')} />;\n}\n```\n\nModule-level definitions are evaluated once. Creating styles inside components causes unnecessary work on every render.\n\n### 2. Avoid dynamic style values\n\n```ts\n// ❌ Bad - creates styles for every possible value\nconst box = styles.create('box', {\n  base: { width: props.width }, // Dynamic values in styles\n});\n\n// ✅ Good - use inline styles for dynamic values\nconst box = styles.create('box', {\n  base: { display: 'block' },\n});\n\nfunction Box({ width }) {\n  return (\n    <div\n      className={box('base')}\n      style={{ width }} // Dynamic value here\n    />\n  );\n}\n```\n\nDynamic values in style objects require JavaScript to run for every value change. Inline styles are handled natively by the browser.\n\n### 3. Reuse token references\n\n```ts\n// ✅ Good - reference the token object\nconst color = tokens.create('color', {\n  primary: '#0066ff',\n});\n\nconst button = styles.create('button', {\n  base: { color: color.primary },\n});\n\nconst link = styles.create('link', {\n  base: { color: color.primary }, // Same reference\n});\n\n// ❌ Bad - recreate values\nconst button = styles.create('button', {\n  base: { color: '#0066ff' },\n});\n\nconst link = styles.create('link', {\n  base: { color: '#0066ff' }, // Duplicated value\n});\n```\n\nTokens ensure consistency and reduce memory usage.\n\n### 4. Minimize variants\n\n```ts\n// ❌ Bad - too many variants for rarely used combinations\nconst button = styles.create('button', {\n  base: { ... },\n  primary: { ... },\n  secondary: { ... },\n  primarySmall: { ... },      // Redundant\n  primaryLarge: { ... },      // Redundant\n  secondarySmall: { ... },    // Redundant\n  secondaryLarge: { ... },    // Redundant\n});\n\n// ✅ Good - compose smaller variants\nconst button = styles.create('button', {\n  base: { ... },\n  primary: { ... },\n  secondary: { ... },\n  small: { ... },\n  large: { ... },\n});\n\n// Usage: button('base', 'primary', 'small')\n```\n\nComposing variants reduces the number of CSS rules and makes your styles more flexible.\n\n### 5. Code split your styles\n\n```ts\n// ✅ Good - load styles on demand\nconst HeavyComponent = lazy(() => import('./HeavyComponent'));\n\n// HeavyComponent.styles.ts is only loaded when needed\n```\n\nSince styles are co-located with components, code splitting works automatically.\n\n### 6. Avoid deeply nested selectors\n\n```ts\n// ❌ Bad - deep nesting increases selector complexity\nconst card = styles.create('card', {\n  base: {\n    '& .header': {\n      '& .title': {\n        '& span': { // Too deep!\n          fontWeight: 'bold',\n        },\n      },\n    },\n  },\n});\n\n// ✅ Good - flatter structure, separate styles\nconst card = styles.create('card', {\n  base: { ... },\n});\n\nconst cardTitle = styles.create('card-title', {\n  base: { fontWeight: 'bold' },\n});\n```\n\nDeep nesting makes CSS harder to maintain and can impact selector matching performance.\n\n## Benchmarks\n\n### Style creation\n\n```\nCreating 1000 style definitions:\n- TypeStyles: ~15ms\n- styled-components: ~150ms\n- Emotion: ~80ms\n```\n\n### Selector calls (class name generation)\n\n```\nGenerating 10,000 class name strings:\n- TypeStyles: ~2ms\n- styled-components: ~50ms (includes hash computation)\n- Emotion: ~30ms (includes hash computation)\n```\n\n### Initial render (injecting CSS)\n\n```\nRendering 100 components with unique styles:\n- TypeStyles: ~25ms\n- styled-components: ~100ms\n- Emotion: ~60ms\n```\n\n_Benchmarks run on M1 Mac, Chrome 120. Your results may vary._\n\n## Measuring performance\n\n### DevTools profiling\n\nTo measure typestyles performance in your app:\n\n1. **Chrome DevTools Performance tab:**\n   - Record a profile during initial render\n   - Look for `insertRule` calls\n   - Check total time spent in typestyles functions\n\n2. **Lighthouse:**\n   - Run performance audit\n   - Check \"Reduce unused CSS\" (should be minimal with lazy injection)\n   - Check \"Minimize main-thread work\"\n\n3. **React DevTools Profiler:**\n   - Profile component renders\n   - Selector calls are fast and won't show up prominently\n\n### Performance marks\n\nAdd marks to measure specific operations:\n\n```ts\nimport { styles } from 'typestyles';\n\nperformance.mark('styles-create-start');\nconst button = styles.create('button', { ... });\nperformance.mark('styles-create-end');\n\nperformance.measure(\n  'styles-create',\n  'styles-create-start',\n  'styles-create-end'\n);\n\n// Check in DevTools > Performance > Timings\n```\n\n## Memory leaks\n\n### Potential issues\n\n**1. Creating styles in event handlers:**\n\n```ts\n// ❌ Bad - creates styles on every click\nfunction handleClick() {\n  const button = styles.create('dynamic-button', { ... });\n  // This accumulates in memory!\n}\n```\n\n**2. Not cleaning up in long-lived apps:**\n\nTypeStyles doesn't automatically clean up unused styles. In most apps this isn't a problem because:\n\n- Style definitions are small\n- CSS rules are reused\n- Apps don't have infinite style variations\n\nHowever, if you're dynamically creating thousands of styles:\n\n```ts\n// If you must create dynamic styles, consider cleanup\n// (Not built into typestyles - implement at app level)\n```\n\n### Best practices to avoid leaks\n\n1. Always define styles at module level\n2. Don't create styles based on user input or dynamic data\n3. Use inline styles for truly dynamic values\n4. Limit the number of unique style variations\n\n## Server-side rendering performance\n\n### CSS extraction\n\nSSR adds minimal overhead:\n\n```ts\nconst { html, css } = collectStyles(() => renderToString(<App />));\n```\n\nThe `collectStyles` call:\n\n1. Captures all CSS to a string buffer (synchronous)\n2. No DOM operations (server environment)\n3. Returns CSS ready to embed in HTML\n\n**Performance tips:**\n\n- Cache SSR output when possible\n- Use streaming SSR with care (requires two renders for style collection)\n- The CSS string is typically small (< 10KB gzipped)\n\n### CSS size\n\nTypical CSS output sizes:\n\n- Small app (10-20 components): ~5KB\n- Medium app (50-100 components): ~15KB\n- Large app (200+ components): ~40KB\n\nThese are usually smaller than equivalent CSS files because:\n\n- Unused styles aren't included\n- No vendor prefixes (handled by browser)\n- Minimal whitespace in generated CSS\n\n## Comparison with CSS files\n\n### CSS files (traditional approach)\n\n**Pros:**\n\n- Zero runtime cost\n- Cacheable separately\n- Familiar tooling\n\n**Cons:**\n\n- No type safety\n- Global namespace\n- Harder to code split\n\n### TypeStyles\n\n**Pros:**\n\n- Type safety\n- Scoped styles (via class names)\n- Automatic code splitting\n- Easy theming\n- Minimal runtime cost\n\n**Cons:**\n\n- Small runtime (~3KB)\n- Runtime CSS injection (one-time cost)\n- Requires JavaScript\n\n**When to use CSS files:**\n\n- Static sites with no interactivity\n- When you don't need type safety\n- Design systems with stable CSS\n\n**When to use typestyles:**\n\n- Interactive applications\n- When type safety matters\n- Complex theming requirements\n- Component libraries\n\n## Optimizing for production\n\n### Build-time considerations\n\nTypeStyles works the same in development and production. There's no build step or optimization needed.\n\nHowever, you can optimize your build:\n\n1. **Tree shaking:** Unused typestyles code is removed by your bundler\n2. **Minification:** CSS in strings is minified along with JS\n3. **Code splitting:** Lazy-loaded components bring their styles automatically\n\n### Production checklist\n\n- [ ] No `styles.create()` calls inside components\n- [ ] No dynamic values in style objects\n- [ ] Tokens reused across components\n- [ ] Variants composed, not multiplied\n- [ ] Test performance on low-end devices\n- [ ] Monitor Core Web Vitals (CLS, LCP, INP)\n\n## Monitoring real-world performance\n\n### Web Vitals\n\nTrack these metrics in production:\n\n- **LCP (Largest Contentful Paint):** Should be < 2.5s\n  - TypeStyles doesn't block rendering (lazy injection)\n- **INP (Interaction to Next Paint):** Should be < 200ms\n  - Selector calls are fast (< 0.01ms)\n- **CLS (Cumulative Layout Shift):** Should be < 0.1\n  - Styles are available before paint (if using SSR)\n\n### Real User Monitoring (RUM)\n\n```ts\n// Send metrics to analytics\nimport { getCLS, getFCP, getFID, getLCP, getTTFB } from 'web-vitals';\n\ngetCLS(console.log);\ngetFCP(console.log);\ngetFID(console.log);\ngetLCP(console.log);\ngetTTFB(console.log);\n```\n\n## Summary\n\nTypeStyles performance characteristics:\n\n- **Bundle size:** ~3.2KB (one of the smallest CSS-in-JS libraries)\n- **Runtime cost:** Minimal (string concatenation + batched DOM inserts)\n- **Memory:** Low (~50KB for typical app)\n- **Rendering:** No blocking, lazy injection\n- **SSR:** Fast extraction, minimal overhead\n\nTo maintain good performance:\n\n1. Define styles at module level\n2. Use inline styles for dynamic values\n3. Compose variants instead of multiplying them\n4. Let code splitting handle lazy loading\n5. Profile if you have concerns\n\nTypeStyles is designed to be fast enough for almost all applications while providing excellent developer experience.\n",
    "title": "Performance",
    "description": "Understanding and optimizing typestyles performance",
    "_meta": {
      "filePath": "performance.md",
      "fileName": "performance.md",
      "directory": ".",
      "extension": "md",
      "path": "performance"
    }
  },
  {
    "content": "\n# React Integration\n\nTypeStyles works seamlessly with React. This guide shows common patterns for integrating typestyles into React applications.\n\n## Basic component setup\n\n### Simple button component\n\n```tsx\n// components/Button/Button.tsx\nimport { styles } from 'typestyles';\nimport { color, space } from '../../tokens';\n\nconst button = styles.create('button', {\n  base: {\n    display: 'inline-flex',\n    alignItems: 'center',\n    justifyContent: 'center',\n    padding: `${space.sm} ${space.md}`,\n    borderRadius: '6px',\n    fontSize: '14px',\n    fontWeight: 500,\n    cursor: 'pointer',\n    border: 'none',\n    transition: 'background-color 150ms ease',\n  },\n  primary: {\n    backgroundColor: color.primary,\n    color: '#fff',\n    '&:hover': {\n      backgroundColor: color.primaryHover,\n    },\n  },\n  secondary: {\n    backgroundColor: color.secondary,\n    color: '#fff',\n    '&:hover': {\n      backgroundColor: color.secondaryHover,\n    },\n  },\n  small: {\n    padding: `${space.xs} ${space.sm}`,\n    fontSize: '12px',\n  },\n  large: {\n    padding: `${space.md} ${space.lg}`,\n    fontSize: '16px',\n  },\n  disabled: {\n    opacity: 0.5,\n    cursor: 'not-allowed',\n  },\n  loading: {\n    cursor: 'wait',\n  },\n});\n\ninterface ButtonProps {\n  variant?: 'primary' | 'secondary';\n  size?: 'small' | 'medium' | 'large';\n  disabled?: boolean;\n  loading?: boolean;\n  onClick?: () => void;\n  children: React.ReactNode;\n}\n\nexport function Button({\n  variant = 'primary',\n  size = 'medium',\n  disabled = false,\n  loading = false,\n  onClick,\n  children,\n}: ButtonProps) {\n  return (\n    <button\n      className={button(\n        'base',\n        variant,\n        size === 'small' && 'small',\n        size === 'large' && 'large',\n        disabled && 'disabled',\n        loading && 'loading',\n      )}\n      onClick={onClick}\n      disabled={disabled || loading}\n    >\n      {loading ? 'Loading...' : children}\n    </button>\n  );\n}\n```\n\n### Using the button\n\n```tsx\n// App.tsx\nimport { Button } from './components/Button';\n\nfunction App() {\n  return (\n    <div>\n      <Button variant=\"primary\">Primary</Button>\n      <Button variant=\"secondary\">Secondary</Button>\n      <Button size=\"large\">Large</Button>\n      <Button disabled>Disabled</Button>\n      <Button loading>Loading</Button>\n    </div>\n  );\n}\n```\n\n## Polymorphic components\n\n### Creating a polymorphic Box component\n\n```tsx\n// components/Box/Box.tsx\nimport { styles } from 'typestyles';\nimport { space } from '../../tokens';\nimport type { ElementType, ComponentPropsWithoutRef } from 'react';\n\nconst box = styles.create('box', {\n  base: {},\n  flex: { display: 'flex' },\n  block: { display: 'block' },\n  inline: { display: 'inline' },\n  hidden: { display: 'none' },\n  gap1: { gap: space[1] },\n  gap2: { gap: space[2] },\n  gap3: { gap: space[3] },\n  gap4: { gap: space[4] },\n  row: { flexDirection: 'row' },\n  column: { flexDirection: 'column' },\n  wrap: { flexWrap: 'wrap' },\n  center: {\n    justifyContent: 'center',\n    alignItems: 'center',\n  },\n  p1: { padding: space[1] },\n  p2: { padding: space[2] },\n  p3: { padding: space[3] },\n  p4: { padding: space[4] },\n  m1: { margin: space[1] },\n  m2: { margin: space[2] },\n  m3: { margin: space[3] },\n  m4: { margin: space[4] },\n});\n\ntype BoxProps<T extends ElementType = 'div'> = {\n  as?: T;\n  display?: 'flex' | 'block' | 'inline' | 'hidden';\n  gap?: 1 | 2 | 3 | 4;\n  direction?: 'row' | 'column';\n  wrap?: boolean;\n  center?: boolean;\n  padding?: 1 | 2 | 3 | 4;\n  margin?: 1 | 2 | 3 | 4;\n} & Omit<ComponentPropsWithoutRef<T>, 'as'>;\n\nexport function Box<T extends ElementType = 'div'>({\n  as,\n  display,\n  gap,\n  direction,\n  wrap,\n  center,\n  padding,\n  margin,\n  className,\n  ...props\n}: BoxProps<T>) {\n  const Component = as || 'div';\n\n  return (\n    <Component\n      className={box(\n        'base',\n        display,\n        gap && `gap${gap}`,\n        direction,\n        wrap && 'wrap',\n        center && 'center',\n        padding && `p${padding}`,\n        margin && `m${margin}`,\n        className,\n      )}\n      {...props}\n    />\n  );\n}\n```\n\n### Using Box as different elements\n\n```tsx\n// Using as a div (default)\n<Box display=\"flex\" gap={2} padding={3}>\n  Content\n</Box>\n\n// Using as a button\n<Box as=\"button\" display=\"flex\" center padding={2}>\n  Click me\n</Box>\n\n// Using as a link\n<Box as=\"a\" href=\"/about\" display=\"inline\" padding={1}>\n  About\n</Box>\n\n// Using with custom component\n<Box as={CustomComponent} display=\"block\" padding={4}>\n  Content\n</Box>\n```\n\n## Compound components\n\n### Card component with multiple parts\n\n```tsx\n// components/Card/Card.tsx\nimport { styles } from 'typestyles';\nimport { color, space } from '../../tokens';\nimport { createContext, useContext, type ReactNode } from 'react';\n\nconst card = styles.create('card', {\n  base: {\n    borderRadius: '8px',\n    backgroundColor: color.surface,\n    border: `1px solid ${color.border}`,\n    overflow: 'hidden',\n  },\n  elevated: {\n    boxShadow: '0 4px 6px rgba(0, 0, 0, 0.1)',\n  },\n  interactive: {\n    cursor: 'pointer',\n    transition: 'box-shadow 200ms ease',\n    '&:hover': {\n      boxShadow: '0 8px 12px rgba(0, 0, 0, 0.15)',\n    },\n  },\n});\n\nconst cardHeader = styles.create('card-header', {\n  base: {\n    padding: `${space.md} ${space.lg}`,\n    borderBottom: `1px solid ${color.border}`,\n  },\n});\n\nconst cardBody = styles.create('card-body', {\n  base: {\n    padding: space.lg,\n  },\n});\n\nconst cardFooter = styles.create('card-footer', {\n  base: {\n    padding: `${space.md} ${space.lg}`,\n    borderTop: `1px solid ${color.border}`,\n    backgroundColor: color.surfaceRaised,\n  },\n});\n\n// Context for sharing state between compound components\ninterface CardContextValue {\n  isInteractive: boolean;\n}\n\nconst CardContext = createContext<CardContextValue>({ isInteractive: false });\n\n// Main Card component\ninterface CardProps {\n  elevated?: boolean;\n  interactive?: boolean;\n  onClick?: () => void;\n  children: ReactNode;\n}\n\nexport function Card({ elevated = false, interactive = false, onClick, children }: CardProps) {\n  return (\n    <CardContext.Provider value={{ isInteractive: interactive }}>\n      <div\n        className={card('base', elevated && 'elevated', interactive && 'interactive')}\n        onClick={onClick}\n        role={interactive ? 'button' : undefined}\n        tabIndex={interactive ? 0 : undefined}\n      >\n        {children}\n      </div>\n    </CardContext.Provider>\n  );\n}\n\n// Card.Header\nCard.Header = function CardHeader({ children }: { children: ReactNode }) {\n  return <div className={cardHeader('base')}>{children}</div>;\n};\n\n// Card.Body\nCard.Body = function CardBody({ children }: { children: ReactNode }) {\n  return <div className={cardBody('base')}>{children}</div>;\n};\n\n// Card.Footer\nCard.Footer = function CardFooter({ children }: { children: ReactNode }) {\n  return <div className={cardFooter('base')}>{children}</div>;\n};\n```\n\n### Using compound components\n\n```tsx\nimport { Card } from './components/Card';\n\nfunction Example() {\n  return (\n    <Card elevated interactive onClick={() => console.log('Clicked!')}>\n      <Card.Header>\n        <h3>Card Title</h3>\n      </Card.Header>\n      <Card.Body>\n        <p>Card content goes here...</p>\n      </Card.Body>\n      <Card.Footer>\n        <button>Action</button>\n      </Card.Footer>\n    </Card>\n  );\n}\n```\n\n## Form components\n\n### Input with validation states\n\n```tsx\n// components/Input/Input.tsx\nimport { styles } from 'typestyles';\nimport { color, space } from '../../tokens';\nimport { forwardRef } from 'react';\n\nconst input = styles.create('input', {\n  base: {\n    width: '100%',\n    padding: `${space.sm} ${space.md}`,\n    borderRadius: '6px',\n    border: `1px solid ${color.border}`,\n    fontSize: '14px',\n    lineHeight: '1.5',\n    backgroundColor: color.surface,\n    color: color.text,\n    transition: 'border-color 150ms ease, box-shadow 150ms ease',\n\n    '&:focus': {\n      outline: 'none',\n      borderColor: color.primary,\n      boxShadow: `0 0 0 3px ${color.alpha(color.primary, 0.1)}`,\n    },\n\n    '&::placeholder': {\n      color: color.textMuted,\n    },\n\n    '&:disabled': {\n      backgroundColor: color.surfaceSunken,\n      cursor: 'not-allowed',\n    },\n  },\n  error: {\n    borderColor: color.danger,\n\n    '&:focus': {\n      borderColor: color.danger,\n      boxShadow: `0 0 0 3px ${color.alpha(color.danger, 0.1)}`,\n    },\n  },\n  success: {\n    borderColor: color.success,\n\n    '&:focus': {\n      borderColor: color.success,\n      boxShadow: `0 0 0 3px ${color.alpha(color.success, 0.1)}`,\n    },\n  },\n});\n\ninterface InputProps extends React.InputHTMLAttributes<HTMLInputElement> {\n  error?: boolean;\n  success?: boolean;\n  label?: string;\n  helperText?: string;\n}\n\nexport const Input = forwardRef<HTMLInputElement, InputProps>(\n  ({ error, success, label, helperText, className, ...props }, ref) => {\n    return (\n      <div className={inputWrapper('base')}>\n        {label && <label className={inputLabel('base')}>{label}</label>}\n        <input\n          ref={ref}\n          className={input('base', error && 'error', success && 'success', className)}\n          {...props}\n        />\n        {helperText && (\n          <span className={inputHelper('base', error && 'error', success && 'success')}>\n            {helperText}\n          </span>\n        )}\n      </div>\n    );\n  },\n);\n\nInput.displayName = 'Input';\n\n// Additional styles for the wrapper, label, and helper\nconst inputWrapper = styles.create('input-wrapper', {\n  base: {\n    display: 'flex',\n    flexDirection: 'column',\n    gap: space.sm,\n  },\n});\n\nconst inputLabel = styles.create('input-label', {\n  base: {\n    fontSize: '14px',\n    fontWeight: 500,\n    color: color.text,\n  },\n});\n\nconst inputHelper = styles.create('input-helper', {\n  base: {\n    fontSize: '12px',\n    color: color.textMuted,\n  },\n  error: {\n    color: color.danger,\n  },\n  success: {\n    color: color.success,\n  },\n});\n```\n\n## Lists and grids\n\n### Responsive grid component\n\n```tsx\n// components/Grid/Grid.tsx\nimport { styles } from 'typestyles';\nimport { space } from '../../tokens';\nimport type { ReactNode } from 'react';\n\nconst grid = styles.create('grid', {\n  base: {\n    display: 'grid',\n    gap: space.md,\n  },\n  cols1: { gridTemplateColumns: 'repeat(1, 1fr)' },\n  cols2: { gridTemplateColumns: 'repeat(2, 1fr)' },\n  cols3: { gridTemplateColumns: 'repeat(3, 1fr)' },\n  cols4: { gridTemplateColumns: 'repeat(4, 1fr)' },\n  cols6: { gridTemplateColumns: 'repeat(6, 1fr)' },\n  cols12: { gridTemplateColumns: 'repeat(12, 1fr)' },\n\n  // Responsive columns\n  '@media (min-width: 640px)': {\n    smCols1: { gridTemplateColumns: 'repeat(1, 1fr)' },\n    smCols2: { gridTemplateColumns: 'repeat(2, 1fr)' },\n    smCols3: { gridTemplateColumns: 'repeat(3, 1fr)' },\n  },\n  '@media (min-width: 768px)': {\n    mdCols1: { gridTemplateColumns: 'repeat(1, 1fr)' },\n    mdCols2: { gridTemplateColumns: 'repeat(2, 1fr)' },\n    mdCols3: { gridTemplateColumns: 'repeat(3, 1fr)' },\n    mdCols4: { gridTemplateColumns: 'repeat(4, 1fr)' },\n  },\n  '@media (min-width: 1024px)': {\n    lgCols1: { gridTemplateColumns: 'repeat(1, 1fr)' },\n    lgCols2: { gridTemplateColumns: 'repeat(2, 1fr)' },\n    lgCols3: { gridTemplateColumns: 'repeat(3, 1fr)' },\n    lgCols4: { gridTemplateColumns: 'repeat(4, 1fr)' },\n    lgCols6: { gridTemplateColumns: 'repeat(6, 1fr)' },\n  },\n});\n\ninterface GridProps {\n  columns?: 1 | 2 | 3 | 4 | 6 | 12;\n  smColumns?: 1 | 2 | 3 | 4;\n  mdColumns?: 1 | 2 | 3 | 4;\n  lgColumns?: 1 | 2 | 3 | 4 | 6;\n  gap?: 'none' | 'sm' | 'md' | 'lg';\n  children: ReactNode;\n}\n\nexport function Grid({\n  columns = 1,\n  smColumns,\n  mdColumns,\n  lgColumns,\n  gap = 'md',\n  children,\n}: GridProps) {\n  return (\n    <div\n      className={grid(\n        'base',\n        `cols${columns}`,\n        smColumns && `smCols${smColumns}`,\n        mdColumns && `mdCols${mdColumns}`,\n        lgColumns && `lgCols${lgColumns}`,\n      )}\n      style={{ gap: gap === 'none' ? 0 : undefined }}\n    >\n      {children}\n    </div>\n  );\n}\n```\n\n## Context and theming\n\n### Theme provider\n\n```tsx\n// components/ThemeProvider/ThemeProvider.tsx\nimport { createContext, useContext, useState, type ReactNode } from 'react';\nimport { darkTheme } from '../../tokens';\n\ninterface ThemeContextValue {\n  isDark: boolean;\n  toggle: () => void;\n}\n\nconst ThemeContext = createContext<ThemeContextValue>({\n  isDark: false,\n  toggle: () => {},\n});\n\nexport function useTheme() {\n  return useContext(ThemeContext);\n}\n\ninterface ThemeProviderProps {\n  children: ReactNode;\n}\n\nexport function ThemeProvider({ children }: ThemeProviderProps) {\n  const [isDark, setIsDark] = useState(() => {\n    if (typeof window === 'undefined') return false;\n    return document.documentElement.classList.contains('theme-dark');\n  });\n\n  const toggle = () => {\n    setIsDark(!isDark);\n    if (!isDark) {\n      document.documentElement.classList.add('theme-dark');\n      localStorage.setItem('theme', 'dark');\n    } else {\n      document.documentElement.classList.remove('theme-dark');\n      localStorage.setItem('theme', 'light');\n    }\n  };\n\n  return (\n    <ThemeContext.Provider value={{ isDark, toggle }}>\n      <div className={isDark ? darkTheme : ''}>{children}</div>\n    </ThemeContext.Provider>\n  );\n}\n```\n\n### Using the theme\n\n```tsx\n// components/ThemeToggle/ThemeToggle.tsx\nimport { useTheme } from '../ThemeProvider';\nimport { Button } from '../Button';\n\nexport function ThemeToggle() {\n  const { isDark, toggle } = useTheme();\n\n  return (\n    <Button variant=\"secondary\" onClick={toggle}>\n      {isDark ? '🌞 Light mode' : '🌙 Dark mode'}\n    </Button>\n  );\n}\n```\n\n## Performance optimization\n\n### Memoized class names\n\nFor components that re-render frequently, you can memoize class name generation:\n\n```tsx\nimport { useMemo } from 'react';\nimport { button } from './button.styles';\n\nfunction OptimizedButton({ variant, size, disabled }) {\n  const className = useMemo(\n    () => button('base', variant, size, disabled && 'disabled'),\n    [variant, size, disabled],\n  );\n\n  return <button className={className}>Click</button>;\n}\n```\n\nHowever, this is usually unnecessary since the selector function is already very fast.\n\n### Code splitting\n\n```tsx\n// Lazy load heavy components with their styles\nconst HeavyChart = lazy(() => import('./components/HeavyChart'));\n\nfunction App() {\n  return (\n    <Suspense fallback={<Loading />}>\n      <HeavyChart />\n    </Suspense>\n  );\n}\n```\n\nThe styles in `HeavyChart` are only loaded when the component is imported.\n\n## TypeScript best practices\n\n### Export component prop types\n\n```tsx\n// components/Button/Button.tsx\nexport interface ButtonProps {\n  variant?: 'primary' | 'secondary';\n  size?: 'small' | 'medium' | 'large';\n  // ...\n}\n\nexport function Button(props: ButtonProps) {\n  // ...\n}\n```\n\n### Use strict prop types\n\n```tsx\n// Good - strict typing\ntype ButtonVariant = 'primary' | 'secondary' | 'ghost';\n\ninterface ButtonProps {\n  variant?: ButtonVariant;\n}\n\n// Avoid - too permissive\ninterface ButtonProps {\n  variant?: string; // Too broad\n}\n```\n\n## Summary\n\nKey patterns for React + typestyles:\n\n1. **Define styles at module level** - Never in components\n2. **Use TypeScript for prop types** - Get autocomplete and error checking\n3. **Compose variants** - Build flexible component APIs\n4. **Consider polymorphism** - `as` prop for versatile components\n5. **Leverage context** - Share state between compound components\n6. **Memoize if needed** - But profile first, selector functions are fast\n7. **Code split naturally** - Styles follow component boundaries\n",
    "title": "React Integration",
    "description": "Using typestyles with React patterns and best practices",
    "_meta": {
      "filePath": "react-integration.md",
      "fileName": "react-integration.md",
      "directory": ".",
      "extension": "md",
      "path": "react-integration"
    }
  },
  {
    "content": "\n# Server-Side Rendering (SSR)\n\nTypeStyles supports SSR out of the box. Instead of injecting styles into the DOM during rendering, you can collect all the CSS on the server and include it in the HTML response.\n\n## Basic setup\n\nImport `collectStyles` from `typestyles/server`:\n\n```ts\nimport { collectStyles } from 'typestyles/server';\nimport { renderToString } from 'react-dom/server';\n\nconst { html, css } = collectStyles(() => renderToString(<App />));\n```\n\nThe `collectStyles` function:\n\n1. Starts collecting CSS instead of injecting it\n2. Runs your render function\n3. Returns the rendered HTML and collected CSS\n\n## Full example\n\nHere's a complete Express.js example:\n\n```ts\nimport express from 'express';\nimport { collectStyles } from 'typestyles/server';\nimport { renderToString } from 'react-dom/server';\nimport { App } from './App';\n\nconst app = express();\n\napp.get('/', (req, res) => {\n  const { html, css } = collectStyles(() => renderToString(<App />));\n\n  res.send(`\n    <!DOCTYPE html>\n    <html>\n      <head>\n        <meta charset=\"utf-8\" />\n        <title>My App</title>\n        <style id=\"typestyles\">${css}</style>\n      </head>\n      <body>\n        <div id=\"root\">${html}</div>\n        <script src=\"/client.js\"></script>\n      </body>\n    </html>\n  `);\n});\n\napp.listen(3000);\n```\n\n## How it works\n\nDuring SSR:\n\n1. **Collection mode**: When `collectStyles()` wraps your render, TypeStyles switches to collection mode\n2. **CSS capture**: All styles, tokens, themes, and keyframes are captured to a buffer instead of being injected into the DOM\n3. **Single style tag**: The collected CSS is returned as a single string ready to embed in your HTML\n\nOn the client:\n\n1. **Hydration detection**: TypeStyles looks for an existing `<style id=\"typestyles\">` element\n2. **Reuse**: If found, it reuses that element and avoids re-injecting the CSS\n3. **Seamless transition**: No flicker or style recalculation during hydration\n\n## Framework-specific examples\n\n### Next.js (App Router)\n\n```tsx\n// app/layout.tsx\nimport { collectStyles } from 'typestyles/server';\nimport { Stylesheet } from './stylesheet';\n\nexport default function RootLayout({ children }: { children: React.ReactNode }) {\n  return (\n    <html>\n      <head>\n        <Stylesheet />\n      </head>\n      <body>{children}</body>\n    </html>\n  );\n}\n\n// app/stylesheet.tsx\nimport { collectStyles } from 'typestyles/server';\nimport { renderToString } from 'react-dom/server';\nimport { YourAppContent } from './your-app-content';\n\nexport function Stylesheet() {\n  // Collect styles from your app\n  const { css } = collectStyles(() => renderToString(<YourAppContent />));\n\n  return <style id=\"typestyles\" dangerouslySetInnerHTML={{ __html: css }} />;\n}\n```\n\n### Next.js (Pages Router)\n\n```tsx\n// pages/_document.tsx\nimport Document, { Html, Head, Main, NextScript, DocumentContext } from 'next/document';\nimport { collectStyles } from 'typestyles/server';\nimport { renderToString } from 'react-dom/server';\n\nclass MyDocument extends Document {\n  static async getInitialProps(ctx: DocumentContext) {\n    const originalRenderPage = ctx.renderPage;\n\n    let css = '';\n    ctx.renderPage = () => {\n      const { css: collectedCss } = collectStyles(() => originalRenderPage());\n      css = collectedCss;\n      return {} as any;\n    };\n\n    const initialProps = await Document.getInitialProps(ctx);\n\n    return {\n      ...initialProps,\n      styles: (\n        <>\n          {initialProps.styles}\n          <style id=\"typestyles\">{css}</style>\n        </>\n      ),\n    };\n  }\n\n  render() {\n    return (\n      <Html>\n        <Head />\n        <body>\n          <Main />\n          <NextScript />\n        </body>\n      </Html>\n    );\n  }\n}\n\nexport default MyDocument;\n```\n\n### Remix\n\n```tsx\n// app/entry.server.tsx\nimport type { EntryContext } from '@remix-run/node';\nimport { RemixServer } from '@remix-run/react';\nimport { renderToString } from 'react-dom/server';\nimport { collectStyles } from 'typestyles/server';\n\nexport default function handleRequest(\n  request: Request,\n  responseStatusCode: number,\n  responseHeaders: Headers,\n  remixContext: EntryContext,\n) {\n  const { html, css } = collectStyles(() =>\n    renderToString(<RemixServer context={remixContext} url={request.url} />),\n  );\n\n  // Inject CSS before Remix handles the response\n  const markup = html.replace('</head>', `<style id=\"typestyles\">${css}</style></head>`);\n\n  return new Response('<!DOCTYPE html>' + markup, {\n    headers: { 'Content-Type': 'text/html' },\n    status: responseStatusCode,\n  });\n}\n```\n\n## Streaming SSR\n\nFor streaming SSR, you need to collect styles before the stream starts:\n\n```tsx\nimport { renderToPipeableStream } from 'react-dom/server';\nimport { collectStyles } from 'typestyles/server';\n\napp.get('/', (req, res) => {\n  // Pre-render to collect styles\n  const { css } = collectStyles(() => renderToString(<App />));\n\n  // Write the head with styles\n  res.write(`\n    <!DOCTYPE html>\n    <html>\n      <head>\n        <style id=\"typestyles\">${css}</style>\n      </head>\n      <body>\n        <div id=\"root\">\n  `);\n\n  // Stream the actual content\n  const stream = renderToPipeableStream(<App />, {\n    onShellReady() {\n      stream.pipe(res);\n    },\n  });\n});\n```\n\nNote: This does render twice (once for styles, once for streaming), but it's necessary because styles are only known after the render completes.\n\n## Important considerations\n\n### Style deduplication\n\nTypeStyles automatically deduplicates CSS during collection. If multiple components use the same style variant, it's only included once in the output.\n\n### Critical CSS\n\nAll CSS is included by default. For large applications, you might want to implement critical CSS extraction (only including styles for above-the-fold content). This isn't built into TypeStyles—you'd need to implement it at the framework level.\n\n### Client-side hydration\n\nAlways use the same `id=\"typestyles\"` on both server and client:\n\n```html\n<!-- Server -->\n<style id=\"typestyles\">\n  ${css}\n</style>\n\n<!-- Client finds and reuses this element -->\n```\n\nIf the IDs don't match, you'll get duplicate styles.\n\n### Memory and cleanup\n\n`collectStyles()` manages collection state automatically. After the render function completes and CSS is collected, the internal state is reset. You don't need to manually clean up.\n\n## Troubleshooting\n\n### Styles missing in SSR output\n\nMake sure you're actually rendering components that use typestyles during the `collectStyles()` call. If styles are defined but the component isn't rendered, no CSS will be generated.\n\n### Styles appearing twice\n\nThis happens when the client can't find the server-rendered style tag:\n\n1. Check that the `id` is exactly `\"typestyles\"`\n2. Make sure the style tag is present in the initial HTML\n3. Verify no ad blockers or CSP are interfering\n\n### Flash of unstyled content (FOUC)\n\nIf you see FOUC:\n\n1. Ensure styles are in the `<head>`, not the body\n2. Check that the CSS string isn't empty\n3. Verify that `collectStyles()` wraps the actual component render, not just an empty render\n",
    "title": "Server-Side Rendering (SSR)",
    "description": "Render typestyles on the server for better performance and SEO",
    "_meta": {
      "filePath": "ssr.md",
      "fileName": "ssr.md",
      "directory": ".",
      "extension": "md",
      "path": "ssr"
    }
  },
  {
    "content": "\n# Styles\n\nThe `styles` API lets you define named style variants and compose them at the call site.\n\n## Creating styles\n\nCall `styles.create(namespace, definitions)` with a unique namespace and an object of variant names to style definitions:\n\n```ts\nimport { styles } from 'typestyles';\n\nconst card = styles.create('card', {\n  base: {\n    padding: '16px',\n    borderRadius: '8px',\n    border: '1px solid #e5e5e5',\n  },\n  elevated: {\n    boxShadow: '0 4px 12px rgba(0,0,0,0.1)',\n  },\n});\n```\n\nClass names are deterministic: `card-base`, `card-elevated`. Combine variants by passing multiple names to the selector function:\n\n```ts\ncard('base', 'elevated'); // \"card-base card-elevated\"\n```\n\n## Selectors\n\nUse the `&` prefix for pseudo-classes and nested selectors, just like in CSS:\n\n```ts\nconst button = styles.create('button', {\n  base: {\n    padding: '8px 16px',\n    '&:hover': { opacity: 0.9 },\n    '&:disabled': { opacity: 0.5, cursor: 'not-allowed' },\n  },\n});\n```\n\n## Composing with tokens\n\nUse token references (e.g. from `tokens.create()`) in your style values. They compile to `var(--name-key)` and work with themes.\n",
    "title": "Styles",
    "description": "Create and compose style variants with styles.create",
    "_meta": {
      "filePath": "styles.md",
      "fileName": "styles.md",
      "directory": ".",
      "extension": "md",
      "path": "styles"
    }
  },
  {
    "content": "\n# Testing\n\nTesting components styled with typestyles is straightforward. Since typestyles generates regular CSS class names, you can use standard testing tools without any special setup.\n\n## Unit testing components\n\n### Basic component testing\n\nSince typestyles returns regular class names, test your components the same way you'd test any React/Vue/Svelte component:\n\n```tsx\n// Button.tsx\nimport { styles } from 'typestyles';\n\nconst button = styles.create('button', {\n  base: { padding: '8px 16px' },\n  primary: { backgroundColor: '#0066ff' },\n  large: { fontSize: '18px' },\n});\n\nexport function Button({ variant, size, children }) {\n  return <button className={button('base', variant, size)}>{children}</button>;\n}\n\n// Button.test.tsx\nimport { render, screen } from '@testing-library/react';\nimport { Button } from './Button';\n\ndescribe('Button', () => {\n  it('renders with base class', () => {\n    render(<Button>Click me</Button>);\n    const button = screen.getByRole('button');\n\n    expect(button).toHaveClass('button-base');\n  });\n\n  it('applies variant classes', () => {\n    render(<Button variant=\"primary\">Click me</Button>);\n    const button = screen.getByRole('button');\n\n    expect(button).toHaveClass('button-base');\n    expect(button).toHaveClass('button-primary');\n  });\n\n  it('applies multiple variants', () => {\n    render(\n      <Button variant=\"primary\" size=\"large\">\n        Click me\n      </Button>,\n    );\n    const button = screen.getByRole('button');\n\n    expect(button).toHaveClass('button-base');\n    expect(button).toHaveClass('button-primary');\n    expect(button).toHaveClass('button-large');\n  });\n});\n```\n\n### Testing conditional classes\n\nWhen variants are applied conditionally, test both states:\n\n```tsx\nfunction Button({ isLoading, children }) {\n  return (\n    <button className={button('base', isLoading && 'loading')}>\n      {isLoading ? 'Loading...' : children}\n    </button>\n  );\n}\n\n// Button.test.tsx\nit('applies loading state', () => {\n  render(<Button isLoading>Click me</Button>);\n  const button = screen.getByRole('button');\n\n  expect(button).toHaveClass('button-base');\n  expect(button).toHaveClass('button-loading');\n});\n\nit('does not apply loading class when not loading', () => {\n  render(<Button>Click me</Button>);\n  const button = screen.getByRole('button');\n\n  expect(button).toHaveClass('button-base');\n  expect(button).not.toHaveClass('button-loading');\n});\n```\n\n## Testing with React Testing Library\n\n### Prefer semantic queries\n\nInstead of testing for specific class names, test for accessible properties when possible:\n\n```tsx\n// ✅ Good - test user-visible behavior\nit('disables button when loading', () => {\n  render(<Button isLoading>Click me</Button>);\n  const button = screen.getByRole('button');\n\n  expect(button).toBeDisabled();\n  expect(button).toHaveTextContent('Loading...');\n});\n\n// Alternative if you need to verify styles\nit('has loading styles', () => {\n  render(<Button isLoading>Click me</Button>);\n  const button = screen.getByRole('button');\n\n  // Verify the class is applied (CSS testing is separate)\n  expect(button).toHaveClass('button-loading');\n});\n```\n\n### Testing style snapshots\n\nIf you want to ensure class names don't change unexpectedly, use snapshots:\n\n```tsx\nit('matches snapshot', () => {\n  const { container } = render(<Button variant=\"primary\">Click me</Button>);\n  expect(container.firstChild).toMatchSnapshot();\n  // Snapshot: <button class=\"button-base button-primary\">Click me</button>\n});\n```\n\n## CSS testing strategies\n\n### Don't test CSS output directly\n\nCSS output is an implementation detail. Test user-facing behavior instead:\n\n```tsx\n// ❌ Avoid - testing implementation details\nit('has padding of 8px', () => {\n  const { container } = render(<Button>Click</Button>);\n  expect(container.firstChild).toHaveStyle({ padding: '8px 16px' });\n});\n\n// ✅ Better - test that the component renders correctly\nit('renders as a button', () => {\n  render(<Button>Click</Button>);\n  expect(screen.getByRole('button')).toBeInTheDocument();\n});\n\n// ✅ Or use visual regression tests for styles\n```\n\n### Visual regression testing\n\nFor CSS testing, use visual regression tools like Chromatic, Percy, or Storybook's visual testing:\n\n```tsx\n// Button.stories.tsx\nimport type { Meta, StoryObj } from '@storybook/react';\nimport { Button } from './Button';\n\nconst meta: Meta<typeof Button> = {\n  component: Button,\n};\n\nexport default meta;\n\ntype Story = StoryObj<typeof Button>;\n\nexport const Primary: Story = {\n  args: {\n    variant: 'primary',\n    children: 'Primary Button',\n  },\n};\n\nexport const Secondary: Story = {\n  args: {\n    variant: 'secondary',\n    children: 'Secondary Button',\n  },\n};\n\nexport const Large: Story = {\n  args: {\n    variant: 'primary',\n    size: 'large',\n    children: 'Large Button',\n  },\n};\n```\n\nRun visual regression tests in CI to catch unintended style changes.\n\n## Testing tokens\n\n### Token value tests\n\nTest that tokens generate the expected CSS:\n\n```ts\n// tokens.test.ts\nimport { tokens } from 'typestyles';\n\ndescribe('tokens', () => {\n  it('creates color token references', () => {\n    const color = tokens.create('color', {\n      primary: '#0066ff',\n    });\n\n    expect(color.primary).toBe('var(--color-primary)');\n  });\n\n  it('creates spacing token references', () => {\n    const space = tokens.create('space', {\n      sm: '8px',\n      md: '16px',\n    });\n\n    expect(space.sm).toBe('var(--space-sm)');\n    expect(space.md).toBe('var(--space-md)');\n  });\n});\n```\n\nNote: Testing the actual CSS output requires DOM access (see integration tests below).\n\n## Integration testing\n\n### Testing with actual styles\n\nFor integration tests, you might want to verify that styles are actually applied:\n\n```tsx\n// setupTests.ts or jest.setup.ts\n// Ensure styles are injected in test environment\nimport 'typestyles';\n\n// For JSDOM-based tests, you may need to mock or stub some CSS APIs\nObject.defineProperty(window, 'CSS', { value: { supports: () => true } });\n```\n\n### Testing computed styles\n\n```tsx\nimport { render } from '@testing-library/react';\nimport { Button } from './Button';\n\nit('applies correct background color', () => {\n  const { getByRole } = render(<Button variant=\"primary\">Click</Button>);\n  const button = getByRole('button');\n\n  // Get computed styles\n  const styles = window.getComputedStyle(button);\n\n  // Note: This may not work in JSDOM as it doesn't fully compute CSS\n  // Better to use visual regression or E2E tests for this\n  expect(styles.backgroundColor).toBeDefined();\n});\n```\n\n⚠️ **Note**: JSDOM doesn't fully support CSS custom properties or computed styles. For testing actual styles, use a real browser with Playwright or Cypress.\n\n## E2E testing\n\n### Playwright example\n\n```ts\n// button.spec.ts\nimport { test, expect } from '@playwright/test';\n\ntest('button has correct styles', async ({ page }) => {\n  await page.goto('/button-demo');\n\n  const button = page.locator('button').first();\n\n  // Check computed styles\n  await expect(button).toHaveCSS('padding', '8px 16px');\n  await expect(button).toHaveCSS('background-color', 'rgb(0, 102, 255)');\n\n  // Check class names\n  await expect(button).toHaveClass(/button-base/);\n  await expect(button).toHaveClass(/button-primary/);\n});\n\ntest('button hover state', async ({ page }) => {\n  await page.goto('/button-demo');\n\n  const button = page.locator('button').first();\n\n  // Hover and check styles\n  await button.hover();\n  await expect(button).toHaveCSS('background-color', 'rgb(0, 82, 204)');\n});\n```\n\n### Cypress example\n\n```ts\n// button.cy.ts\ndescribe('Button', () => {\n  it('has correct classes', () => {\n    cy.visit('/button-demo');\n\n    cy.get('button')\n      .first()\n      .should('have.class', 'button-base')\n      .and('have.class', 'button-primary');\n  });\n\n  it('has correct computed styles', () => {\n    cy.visit('/button-demo');\n\n    cy.get('button')\n      .first()\n      .should('have.css', 'padding', '8px 16px')\n      .and('have.css', 'background-color', 'rgb(0, 102, 255)');\n  });\n});\n```\n\n## Testing SSR\n\nWhen testing SSR-rendered components, ensure styles are collected:\n\n```tsx\n// ssr.test.ts\nimport { collectStyles } from 'typestyles/server';\nimport { renderToString } from 'react-dom/server';\nimport { App } from './App';\n\ndescribe('SSR', () => {\n  it('collects styles during render', () => {\n    const { html, css } = collectStyles(() => renderToString(<App />));\n\n    // HTML should contain class names\n    expect(html).toContain('button-base');\n\n    // CSS should contain the styles\n    expect(css).toContain('.button-base');\n    expect(css).toContain('padding');\n  });\n\n  it('includes CSS custom properties', () => {\n    const { css } = collectStyles(() => renderToString(<App />));\n\n    expect(css).toContain('--color-primary');\n    expect(css).toContain('--space-md');\n  });\n});\n```\n\n## Snapshot testing class names\n\nFor library authors or design systems, you might want to snapshot the generated class names:\n\n```ts\n// styles.test.ts\nimport { styles } from 'typestyles';\n\ndescribe('Button styles', () => {\n  it('generates consistent class names', () => {\n    const button = styles.create('button', {\n      base: { padding: '8px' },\n      primary: { color: 'blue' },\n    });\n\n    expect(button('base')).toMatchInlineSnapshot(`\"button-base\"`);\n    expect(button('base', 'primary')).toMatchInlineSnapshot(`\"button-base button-primary\"`);\n  });\n});\n```\n\n## Mocking typestyles (if needed)\n\nIn rare cases, you might want to mock typestyles:\n\n```ts\n// __mocks__/typestyles.ts\nexport const styles = {\n  create: (namespace: string, definitions: Record<string, any>) => {\n    return (...variants: (string | false | undefined)[]) => {\n      return variants\n        .filter(Boolean)\n        .map((v) => `${namespace}-${v}`)\n        .join(' ');\n    };\n  },\n};\n\nexport const tokens = {\n  create: (namespace: string, values: Record<string, string>) => {\n    return Object.fromEntries(\n      Object.keys(values).map((key) => [key, `var(--${namespace}-${key})`]),\n    );\n  },\n  use: (namespace: string) => {\n    return new Proxy(\n      {},\n      {\n        get: (_, key: string) => `var(--${namespace}-${key})`,\n      },\n    );\n  },\n  createTheme: (name: string) => `theme-${name}`,\n};\n```\n\nHowever, mocking is usually unnecessary since typestyles has minimal side effects in tests.\n\n## Best practices\n\n1. **Test behavior, not classes** - Focus on what users see and interact with\n2. **Use semantic queries** - `getByRole`, `getByText` over class name selectors\n3. **Visual regression for styles** - Use Chromatic/Percy for CSS testing\n4. **E2E for computed styles** - Use Playwright/Cypress to test actual rendering\n5. **Snapshot sparingly** - Only snapshot class names if you're maintaining a library\n6. **Don't test implementation** - CSS output is an implementation detail\n\n## Example test suite\n\nHere's a complete example test suite for a component:\n\n```tsx\n// Card.test.tsx\nimport { render, screen } from '@testing-library/react';\nimport { Card } from './Card';\n\ndescribe('Card', () => {\n  it('renders children', () => {\n    render(<Card>Content</Card>);\n    expect(screen.getByText('Content')).toBeInTheDocument();\n  });\n\n  it('has correct ARIA role', () => {\n    render(<Card>Content</Card>);\n    expect(screen.getByRole('article')).toBeInTheDocument();\n  });\n\n  it('applies elevated variant', () => {\n    render(<Card elevated>Content</Card>);\n    const card = screen.getByRole('article');\n\n    expect(card).toHaveClass('card-base');\n    expect(card).toHaveClass('card-elevated');\n  });\n\n  it('applies interactive variant', () => {\n    render(<Card interactive>Content</Card>);\n    const card = screen.getByRole('article');\n\n    expect(card).toHaveClass('card-base');\n    expect(card).toHaveClass('card-interactive');\n  });\n\n  it('can combine variants', () => {\n    render(\n      <Card elevated interactive>\n        Content\n      </Card>,\n    );\n    const card = screen.getByRole('article');\n\n    expect(card).toHaveClass('card-base');\n    expect(card).toHaveClass('card-elevated');\n    expect(card).toHaveClass('card-interactive');\n  });\n\n  it('matches snapshot', () => {\n    const { container } = render(\n      <Card elevated>\n        <h2>Title</h2>\n        <p>Description</p>\n      </Card>,\n    );\n    expect(container.firstChild).toMatchSnapshot();\n  });\n});\n```\n\nThis approach tests:\n\n- Component rendering\n- Accessibility\n- Variant application\n- Combination of variants\n- Snapshot for unexpected changes\n\nAll without worrying about the actual CSS values, which should be tested via visual regression or E2E tests.\n",
    "title": "Testing",
    "description": "Testing strategies for typestyles components",
    "_meta": {
      "filePath": "testing.md",
      "fileName": "testing.md",
      "directory": ".",
      "extension": "md",
      "path": "testing"
    }
  },
  {
    "content": "\n# Theming Patterns\n\nTypeStyles uses CSS custom properties for theming, making it flexible and powerful. This guide covers common theming patterns.\n\n## Basic light/dark mode\n\n### Creating a theme\n\n```ts\n// tokens.ts\nimport { tokens } from 'typestyles';\n\n// Define your base tokens\nexport const color = tokens.create('color', {\n  // Light mode defaults\n  text: '#111827',\n  textMuted: '#6b7280',\n  surface: '#ffffff',\n  surfaceRaised: '#f9fafb',\n  surfaceSunken: '#f3f4f6',\n  border: '#e5e7eb',\n  primary: '#0066ff',\n  primaryHover: '#0052cc',\n});\n\n// Create dark theme override\nexport const darkTheme = tokens.createTheme('dark', {\n  color: {\n    text: '#e0e0e0',\n    textMuted: '#9ca3af',\n    surface: '#1a1a2e',\n    surfaceRaised: '#25253e',\n    surfaceSunken: '#16162a',\n    border: '#3f3f5c',\n    primary: '#66b3ff',\n    primaryHover: '#3399ff',\n  },\n});\n```\n\n### Applying the theme\n\n```tsx\n// App.tsx\nimport { darkTheme } from './tokens';\n\nfunction App() {\n  const [isDark, setIsDark] = useState(false);\n\n  return (\n    <div className={isDark ? darkTheme : ''}>\n      <button onClick={() => setIsDark(!isDark)}>Toggle theme</button>\n      <PageContent />\n    </div>\n  );\n}\n```\n\n### Persisting theme preference\n\n```tsx\n// hooks/useTheme.ts\nimport { useState, useEffect } from 'react';\nimport { darkTheme } from '../tokens';\n\nexport function useTheme() {\n  const [isDark, setIsDark] = useState(() => {\n    // Check localStorage first\n    if (typeof window !== 'undefined') {\n      const stored = localStorage.getItem('theme');\n      if (stored) return stored === 'dark';\n\n      // Fall back to system preference\n      return window.matchMedia('(prefers-color-scheme: dark)').matches;\n    }\n    return false;\n  });\n\n  useEffect(() => {\n    localStorage.setItem('theme', isDark ? 'dark' : 'light');\n\n    // Optional: Update meta theme-color\n    const meta = document.querySelector('meta[name=\"theme-color\"]');\n    if (meta) {\n      meta.setAttribute('content', isDark ? '#1a1a2e' : '#ffffff');\n    }\n  }, [isDark]);\n\n  return { isDark, theme: isDark ? darkTheme : '', toggle: () => setIsDark(!isDark) };\n}\n```\n\n## System preference detection\n\n### CSS-only approach (no flash)\n\n```ts\n// tokens.ts\nexport const color = tokens.create('color', {\n  text: '#111827',\n  surface: '#ffffff',\n  // ... other tokens\n});\n\nexport const darkTheme = tokens.createTheme('dark', {\n  color: {\n    text: '#e0e0e0',\n    surface: '#1a1a2e',\n  },\n});\n```\n\n```html\n<!-- index.html -->\n<!DOCTYPE html>\n<html>\n  <head>\n    <script>\n      // Prevent flash of wrong theme\n      (function () {\n        const theme =\n          localStorage.getItem('theme') ||\n          (window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'light');\n        if (theme === 'dark') {\n          document.documentElement.classList.add('theme-dark');\n        }\n      })();\n    </script>\n  </head>\n  <body>\n    <div id=\"root\"></div>\n  </body>\n</html>\n```\n\n```tsx\n// App.tsx\nimport { darkTheme } from './tokens';\n\nfunction App() {\n  const [isDark, setIsDark] = useState(() =>\n    document.documentElement.classList.contains('theme-dark'),\n  );\n\n  const toggleTheme = () => {\n    const newTheme = !isDark;\n    setIsDark(newTheme);\n\n    if (newTheme) {\n      document.documentElement.classList.add('theme-dark');\n    } else {\n      document.documentElement.classList.remove('theme-dark');\n    }\n  };\n\n  return <div className={isDark ? darkTheme : ''}>{/* app content */}</div>;\n}\n```\n\n## Multi-brand theming\n\n### Different themes for different contexts\n\n```ts\n// themes.ts\nimport { tokens } from 'typestyles';\n\n// Define base tokens structure\nconst baseTokens = {\n  color: {\n    primary: '',\n    secondary: '',\n    text: '',\n    surface: '',\n  },\n  space: {\n    sm: '8px',\n    md: '16px',\n    lg: '24px',\n  },\n};\n\n// Brand A theme\nexport const brandA = tokens.createTheme('brand-a', {\n  color: {\n    primary: '#0066ff',\n    secondary: '#6b7280',\n    text: '#111827',\n    surface: '#ffffff',\n  },\n});\n\n// Brand B theme\nexport const brandB = tokens.createTheme('brand-b', {\n  color: {\n    primary: '#10b981',\n    secondary: '#f59e0b',\n    text: '#1f2937',\n    surface: '#fafafa',\n  },\n});\n\n// Brand C theme\nexport const brandC = tokens.createTheme('brand-c', {\n  color: {\n    primary: '#ef4444',\n    secondary: '#8b5cf6',\n    text: '#0f172a',\n    surface: '#f8fafc',\n  },\n});\n```\n\n### Applying brand themes\n\n```tsx\n// App.tsx\nimport { brandA, brandB, brandC } from './themes';\n\nconst brands = {\n  a: brandA,\n  b: brandB,\n  c: brandC,\n};\n\nfunction App({ brandId }) {\n  const themeClass = brands[brandId] || brandA;\n\n  return (\n    <div className={themeClass}>\n      <PageContent />\n    </div>\n  );\n}\n```\n\n### Nested themes\n\nThemes can be nested for scoped theming:\n\n```tsx\nimport { brandA, brandB } from './themes';\n\nfunction App() {\n  return (\n    <div className={brandA}>\n      <Header /> {/* Uses brandA colors */}\n      <main>\n        <div className={brandB}>\n          <Widget /> {/* Uses brandB colors */}\n        </div>\n      </main>\n      <Footer /> {/* Uses brandA colors */}\n    </div>\n  );\n}\n```\n\nCSS custom properties cascade naturally, so the inner theme overrides only affect its subtree.\n\n## Component-specific themes\n\n### Isolated component theming\n\n```ts\n// components/Chart/Chart.tokens.ts\nimport { tokens } from 'typestyles';\n\n// Chart-specific tokens that don't affect the rest of the app\nexport const chartTheme = tokens.createTheme('chart', {\n  color: {\n    primary: '#0066ff',\n    secondary: '#10b981',\n    tertiary: '#f59e0b',\n    quaternary: '#ef4444',\n    grid: '#e5e7eb',\n    axis: '#6b7280',\n  },\n});\n```\n\n```tsx\n// components/Chart/Chart.tsx\nimport { chartTheme } from './Chart.tokens';\n\nexport function Chart({ data }) {\n  return (\n    <div className={chartTheme}>\n      <svg className={chart('svg')}>{/* Chart uses chart-specific color tokens */}</svg>\n    </div>\n  );\n}\n```\n\n## Seasonal/time-based themes\n\n### Time-aware theming\n\n```ts\n// themes/seasonal.ts\nimport { tokens } from 'typestyles';\n\nexport const holidayTheme = tokens.createTheme('holiday', {\n  color: {\n    primary: '#c41e3a', // Holiday red\n    secondary: '#165b33', // Holiday green\n    accent: '#ffd700', // Gold\n  },\n});\n\nexport const springTheme = tokens.createTheme('spring', {\n  color: {\n    primary: '#88c999',\n    secondary: '#f4a460',\n    accent: '#ffb6c1',\n  },\n});\n```\n\n```tsx\n// hooks/useSeasonalTheme.ts\nimport { holidayTheme, springTheme } from '../themes/seasonal';\n\nexport function useSeasonalTheme() {\n  const now = new Date();\n  const month = now.getMonth();\n  const day = now.getDate();\n\n  // Holiday season: December\n  if (month === 11) {\n    return holidayTheme;\n  }\n\n  // Spring: March-May\n  if (month >= 2 && month <= 4) {\n    return springTheme;\n  }\n\n  return null; // Use default theme\n}\n```\n\n## Advanced theme composition\n\n### Partial themes\n\n```ts\n// themes/semantics.ts\nimport { tokens } from 'typestyles';\n\n// Semantic color tokens\nexport const successTheme = tokens.createTheme('success', {\n  color: {\n    primary: '#10b981',\n    primaryHover: '#059669',\n  },\n});\n\nexport const warningTheme = tokens.createTheme('warning', {\n  color: {\n    primary: '#f59e0b',\n    primaryHover: '#d97706',\n  },\n});\n\nexport const dangerTheme = tokens.createTheme('danger', {\n  color: {\n    primary: '#ef4444',\n    primaryHover: '#dc2626',\n  },\n});\n```\n\n```tsx\n// components/Alert/Alert.tsx\nimport { successTheme, warningTheme, dangerTheme } from '../../themes/semantics';\n\nconst alertThemes = {\n  success: successTheme,\n  warning: warningTheme,\n  danger: dangerTheme,\n};\n\nexport function Alert({ type, children }) {\n  return <div className={alertThemes[type]}>{children}</div>;\n}\n```\n\n### Token layering\n\n```ts\n// tokens/layers.ts\nimport { tokens } from 'typestyles';\n\n// Layer 1: Primitives\nconst primitives = tokens.create('primitives', {\n  // Raw values\n  blue500: '#0066ff',\n  blue600: '#0052cc',\n  gray500: '#6b7280',\n});\n\n// Layer 2: Semantic tokens\nconst color = tokens.create('color', {\n  // Reference primitives\n  primary: primitives.blue500,\n  primaryHover: primitives.blue600,\n  text: '#111827',\n});\n\n// Layer 3: Component tokens\nconst button = tokens.create('button', {\n  // Reference semantic tokens\n  backgroundColor: color.primary,\n  backgroundColorHover: color.primaryHover,\n  textColor: '#ffffff',\n});\n```\n\n## Accessibility considerations\n\n### High contrast mode\n\n```ts\n// themes/accessibility.ts\nimport { tokens } from 'typestyles';\n\nexport const highContrastTheme = tokens.createTheme('high-contrast', {\n  color: {\n    text: '#000000',\n    surface: '#ffffff',\n    primary: '#0000ff',\n    border: '#000000',\n  },\n});\n```\n\n```tsx\n// hooks/useAccessibility.ts\nexport function useHighContrast() {\n  const [isHighContrast, setIsHighContrast] = useState(false);\n\n  useEffect(() => {\n    const mediaQuery = window.matchMedia('(prefers-contrast: high)');\n    setIsHighContrast(mediaQuery.matches);\n\n    const handler = (e) => setIsHighContrast(e.matches);\n    mediaQuery.addEventListener('change', handler);\n\n    return () => mediaQuery.removeEventListener('change', handler);\n  }, []);\n\n  return isHighContrast;\n}\n```\n\n### Respect user preferences\n\n```ts\n// tokens.ts\nimport { tokens } from 'typestyles';\n\nexport const color = tokens.create('color', {\n  text: '#111827',\n  // ... other tokens\n});\n\nexport const darkTheme = tokens.createTheme('dark', {\n  color: {\n    text: '#e0e0e0',\n    // ... other overrides\n  },\n});\n\nexport const reducedMotionTheme = tokens.createTheme('reduced-motion', {\n  // You could add motion-related tokens here\n});\n```\n\n```tsx\n// App.tsx\nimport { darkTheme } from './tokens';\n\nfunction App() {\n  const prefersDark = useMediaQuery('(prefers-color-scheme: dark)');\n  const prefersReducedMotion = useMediaQuery('(prefers-reduced-motion: reduce)');\n\n  const themeClasses = [prefersDark && darkTheme, prefersReducedMotion && 'reduce-motion']\n    .filter(Boolean)\n    .join(' ');\n\n  return (\n    <div className={themeClasses}>\n      <PageContent />\n    </div>\n  );\n}\n```\n\n## Theme switching transitions\n\n### Smooth theme transitions\n\n```css\n/* Add to your global CSS or a style element */\nhtml,\nbody,\n* {\n  transition:\n    background-color 0.3s ease,\n    color 0.3s ease,\n    border-color 0.3s ease;\n}\n```\n\nOr with typestyles:\n\n```ts\nconst global = styles.create('global', {\n  root: {\n    transition: 'background-color 0.3s ease, color 0.3s ease',\n  },\n});\n\n// Apply to root element\n<div className={global('root')}>\n  {/* app content */}\n</div>\n```\n\n### Prevent flash during theme switch\n\n```tsx\nfunction ThemeProvider({ children }) {\n  const [theme, setTheme] = useState(null);\n  const [isReady, setIsReady] = useState(false);\n\n  useEffect(() => {\n    // Read theme from localStorage or system preference\n    const savedTheme = localStorage.getItem('theme');\n    setTheme(savedTheme === 'dark' ? darkTheme : '');\n    setIsReady(true);\n  }, []);\n\n  // Prevent rendering until theme is determined\n  if (!isReady) {\n    return null; // or a loading spinner\n  }\n\n  return <div className={theme}>{children}</div>;\n}\n```\n\n## SSR with themes\n\n### Server-side theme detection\n\n```ts\n// server.ts\nimport { collectStyles } from 'typestyles/server';\nimport { darkTheme } from './tokens';\n\napp.get('/', (req, res) => {\n  // Detect theme from cookie or user preference\n  const themeCookie = req.cookies.theme;\n  const isDark = themeCookie === 'dark';\n\n  const { html, css } = collectStyles(() =>\n    renderToString(\n      <div className={isDark ? darkTheme : ''}>\n        <App />\n      </div>\n    )\n  );\n\n  res.send(`\n    <!DOCTYPE html>\n    <html class=\"${isDark ? darkTheme : ''}\">\n      <head>\n        <style id=\"typestyles\">${css}</style>\n      </head>\n      <body>\n        <div id=\"root\">${html}</div>\n      </body>\n    </html>\n  `);\n});\n```\n\n## Best practices\n\n1. **Use semantic token names** - `primary`, `surface`, `text` instead of `blue`, `white`, `black`\n2. **Define dark mode alongside light mode** - Keep them in sync\n3. **Test both themes** - Use visual regression for both modes\n4. **Respect system preferences** - Default to `prefers-color-scheme`\n5. **Provide user override** - Let users choose independently of system\n6. **Store preference** - Use localStorage to remember user choice\n7. **Avoid theme flash** - Set theme class before first paint\n8. **Use CSS custom properties** - They cascade naturally for nested themes\n",
    "title": "Theming Patterns",
    "description": "Light/dark mode, multi-brand theming, and advanced theme strategies",
    "_meta": {
      "filePath": "theming-patterns.md",
      "fileName": "theming-patterns.md",
      "directory": ".",
      "extension": "md",
      "path": "theming-patterns"
    }
  },
  {
    "content": "\n# Tokens\n\nTokens are design primitives (colors, spacing, etc.) exposed as CSS custom properties. They keep your styles consistent and make theming straightforward.\n\n## Creating tokens\n\nUse `tokens.create(prefix, object)` to define a set of tokens:\n\n```ts\nimport { tokens } from 'typestyles';\n\nconst space = tokens.create('space', {\n  xs: '4px',\n  sm: '8px',\n  md: '16px',\n  lg: '24px',\n});\n\nconst color = tokens.create('color', {\n  primary: '#0066ff',\n  text: '#111827',\n  border: '#e5e7eb',\n});\n```\n\nEach value becomes a CSS custom property: `--space-xs`, `--color-primary`. The create function returns an object of the same shape whose values are `var(--prefix-key)` so you can use them in styles:\n\n```ts\npadding: space.md,        // var(--space-md)\nbackgroundColor: color.primary,  // var(--color-primary)\n```\n\n## Theming\n\nUse `tokens.createTheme(name, overrides)` to define a theme that overrides token values:\n\n```ts\nconst dark = tokens.createTheme('dark', {\n  color: {\n    primary: '#66b3ff',\n    text: '#e0e0e0',\n    surface: '#1a1a2e',\n  },\n});\n```\n\nApply the theme by adding the theme class to a parent (e.g. `document.body.classList.add(dark)`). All token references under that subtree will use the overridden values.\n",
    "title": "Tokens",
    "description": "Design tokens and theming with tokens.create and createTheme",
    "_meta": {
      "filePath": "tokens.md",
      "fileName": "tokens.md",
      "directory": ".",
      "extension": "md",
      "path": "tokens"
    }
  },
  {
    "content": "\n# Troubleshooting\n\nCommon issues you might encounter and their solutions.\n\n## Styles not applying\n\n### Check the class name\n\nFirst, verify the class name is being applied:\n\n```tsx\nfunction Button() {\n  return <button className={button('base')}>Click me</button>;\n}\n```\n\nOpen DevTools and check that the element has the expected class:\n\n```html\n<!-- Should see something like this -->\n<button class=\"button-base\">Click me</button>\n```\n\n**If no class is present:**\n\n- Check that the component is actually rendering\n- Verify the style definition is being imported\n- Ensure no JavaScript errors are preventing execution\n\n**If class is present but styles don't apply:**\n\n- Check the computed styles in DevTools\n- Verify no other CSS is overriding your styles\n- Look for CSS specificity issues\n\n### Check CSS injection\n\nStyles are injected lazily. Open DevTools and look for a `<style>` tag with typestyles:\n\n```html\n<head>\n  <style id=\"typestyles\">\n    .button-base {\n      padding: 8px 16px;\n    }\n  </style>\n</head>\n```\n\n**If the style tag is missing:**\n\n- Ensure typestyles is actually being imported\n- Check that components using the styles are rendering\n- Verify no bundler issues (check console for errors)\n\n**If styles are in the tag but not applied:**\n\n- Check for CSS syntax errors\n- Verify the class name in HTML matches the CSS selector\n- Look for ad blockers that might be removing styles\n\n## Duplicate namespace warnings\n\n### What it means\n\n```\nStyle namespace \"button\" is also used in /path/to/other/file.ts.\nDuplicate namespaces cause class name collisions.\n```\n\nThis means you've created two different styles with the same namespace:\n\n```ts\n// File A\nconst button = styles.create('button', { ... });\n\n// File B\nconst button = styles.create('button', { ... }); // Same namespace!\n```\n\n### How to fix\n\nUse unique, descriptive namespaces:\n\n```ts\n// ✅ Good - descriptive names\nconst iconButton = styles.create('icon-button', { ... });\nconst textButton = styles.create('text-button', { ... });\nconst submitButton = styles.create('submit-button', { ... });\n\n// ❌ Bad - generic names that collide\nconst button = styles.create('button', { ... });\nconst button2 = styles.create('button', { ... }); // Collision!\n```\n\n## TypeScript errors\n\n### \"Property does not exist\"\n\n```\nProperty 'tertiary' does not exist on type '{ primary: string; secondary: string; }'\n```\n\nYou're trying to access a token that doesn't exist:\n\n```ts\nconst color = tokens.create('color', {\n  primary: '#0066ff',\n  secondary: '#6b7280',\n});\n\ncolor.tertiary; // Error! This token doesn't exist\n```\n\n**Fix:** Add the missing token or use an existing one.\n\n### \"No overload matches this call\"\n\n```\nNo overload matches this call.\n  The last overload gave the following error.\n    Argument of type 'string' is not assignable to parameter of type...\n```\n\nYou're passing an invalid variant:\n\n```ts\nconst button = styles.create('button', {\n  base: { ... },\n  primary: { ... },\n});\n\nbutton('base', 'secondary'); // Error! 'secondary' is not a valid variant\n```\n\n**Fix:** Use only defined variants.\n\n### Cannot find module 'typestyles'\n\n```\nCannot find module 'typestyles' or its corresponding type declarations.\n```\n\n**Fix:**\n\n1. Make sure typestyles is installed:\n\n   ```bash\n   npm install typestyles\n   ```\n\n2. Check your import path:\n\n   ```ts\n   // ✅ Correct\n   import { styles } from 'typestyles';\n\n   // ❌ Incorrect\n   import { styles } from './typestyles';\n   ```\n\n3. Restart TypeScript server in your editor\n\n## SSR issues\n\n### Styles not included in SSR output\n\n**Symptom:** Page renders without styles, then styles appear after hydration (flash of unstyled content).\n\n**Cause:** Not using `collectStyles()` during render.\n\n**Fix:**\n\n```ts\nimport { collectStyles } from 'typestyles/server';\nimport { renderToString } from 'react-dom/server';\n\n// ❌ Wrong\nconst html = renderToString(<App />);\n\n// ✅ Correct\nconst { html, css } = collectStyles(() => renderToString(<App />));\n// Include css in your HTML response\n```\n\n### Hydration mismatch\n\n**Symptom:** React warning about hydration mismatch or styles appearing twice.\n\n**Cause:** Mismatch between server and client CSS injection.\n\n**Fix:**\n\n1. Ensure the style tag ID matches:\n\n   ```html\n   <!-- Server -->\n   <style id=\"typestyles\">\n     ${css}\n   </style>\n\n   <!-- Client looks for this ID -->\n   ```\n\n2. Don't manually create the style tag on client:\n\n   ```tsx\n   // ❌ Don't do this on client\n   document.head.innerHTML += `<style id=\"typestyles\">...</style>`;\n\n   // ✅ TypeStyles handles this automatically\n   ```\n\n### Empty CSS in SSR\n\n**Symptom:** `css` string is empty.\n\n**Cause:** Styles aren't being created during the render pass.\n\n**Fix:** Make sure components with typestyles are actually rendered inside `collectStyles()`:\n\n```ts\n// ❌ Wrong - App doesn't use typestyles components\nconst { css } = collectStyles(() => renderToString(<App />));\n// css is empty because App doesn't use styles\n\n// ✅ Correct - Components with styles are rendered\nconst { css } = collectStyles(() =>\n  renderToString(\n    <App>\n      <Button /> {/* Button uses typestyles */}\n    </App>\n  )\n);\n```\n\n## Build issues\n\n### Bundler errors\n\n**ESM/CJS issues:**\n\nIf you get errors about ES modules:\n\n```json\n// package.json\n{\n  \"type\": \"module\"\n}\n```\n\nOr use `.mjs` extension for your files.\n\n**Webpack issues:**\n\nIf using webpack, ensure it can handle ES modules:\n\n```js\n// webpack.config.js\nmodule.exports = {\n  resolve: {\n    fullySpecified: false,\n  },\n};\n```\n\n### Missing dependencies\n\nIf you see errors about missing dependencies, ensure you've installed typestyles:\n\n```bash\nnpm install typestyles\n\n# If using Vite plugin\nnpm install -D @typestyles/vite\n```\n\n## Runtime errors\n\n### \"Cannot read property 'create' of undefined\"\n\n```\nTypeError: Cannot read property 'create' of undefined\n```\n\n**Cause:** Importing incorrectly.\n\n**Fix:**\n\n```ts\n// ✅ Correct\nimport { styles } from 'typestyles';\n\n// ❌ Incorrect\nimport styles from 'typestyles'; // Wrong! Use named import\n```\n\n### \"insertRule is not a function\"\n\n```\nTypeError: sheet.insertRule is not a function\n```\n\n**Cause:** Running in an environment without a real DOM (like jsdom with some configurations).\n\n**Fix:** Mock the CSSOM APIs in your test setup:\n\n```ts\n// test-setup.ts\nObject.defineProperty(document, 'styleSheets', {\n  value: [\n    {\n      insertRule: jest.fn(),\n      cssRules: [],\n    },\n  ],\n});\n```\n\nOr use a real browser for testing (Playwright, Cypress).\n\n## Styling issues\n\n### Specificity problems\n\nYour styles are being overridden by other CSS:\n\n```css\n/* Your typestyles class */\n.button-base {\n  color: blue;\n}\n\n/* Other CSS overrides it */\nbutton {\n  color: red;\n} /* Higher specificity or loaded later */\n```\n\n**Fixes:**\n\n1. Use more specific selectors:\n\n   ```ts\n   const button = styles.create('button', {\n     base: {\n       color: 'blue',\n       // Increase specificity\n       '&.button-base': {\n         color: 'blue',\n       },\n     },\n   });\n   ```\n\n2. Load typestyles CSS after other CSS\n\n3. Use `!important` (not recommended):\n   ```ts\n   base: {\n     color: 'blue !important',\n   }\n   ```\n\n### Cascade issues\n\nStyles from parent components affecting children:\n\n```ts\nconst parent = styles.create('parent', {\n  base: {\n    '& button': { color: 'red' }, // Affects ALL buttons inside\n  },\n});\n```\n\n**Fix:** Be more specific or avoid nesting:\n\n```ts\nconst parent = styles.create('parent', {\n  base: {\n    // Don't use & button, style specific class instead\n  },\n});\n\nconst childButton = styles.create('child-button', {\n  base: {\n    color: 'red',\n  },\n});\n```\n\n### Media queries not working\n\n```ts\nconst responsive = styles.create('responsive', {\n  base: {\n    '@media (max-width: 768px)': {\n      display: 'none',\n    },\n  },\n});\n```\n\n**Check:**\n\n1. Viewport is actually below 768px\n2. No syntax errors in the media query\n3. Check DevTools to see if the media query CSS was generated\n\n## Theme issues\n\n### Theme not applying\n\n```tsx\nconst darkTheme = tokens.createTheme('dark', {\n  color: {\n    primary: '#66b3ff',\n  },\n});\n\n<div className={darkTheme}>Content</div>;\n```\n\n**Check:**\n\n1. The theme class is applied (check DevTools)\n2. Tokens are being used in styles (not hardcoded values)\n3. The token namespace matches:\n\n   ```ts\n   // Creating\n   const color = tokens.create('color', { ... });\n\n   // Overriding\n   tokens.createTheme('dark', {\n     color: { ... } // Must match 'color' namespace\n   });\n   ```\n\n### Theme flashing on load\n\n**Cause:** Theme is applied after initial render.\n\n**Fix:** Apply theme class before first paint:\n\n```html\n<head>\n  <script>\n    // Set theme immediately\n    const theme = localStorage.getItem('theme');\n    if (theme === 'dark') {\n      document.documentElement.classList.add('theme-dark');\n    }\n  </script>\n</head>\n```\n\n## Vite plugin issues\n\n### HMR not working\n\n1. Check that the plugin is installed and configured:\n\n   ```ts\n   // vite.config.ts\n   import typestyles from '@typestyles/vite';\n\n   export default {\n     plugins: [typestyles()],\n   };\n   ```\n\n2. Ensure files import from `'typestyles'` (not relative paths)\n\n3. Check browser console for HMR-related errors\n\n### \"typestyles is not defined\"\n\n**Cause:** Plugin isn't transforming the file.\n\n**Fix:** Make sure files import from `'typestyles'`:\n\n```ts\n// ✅ This file will be transformed\nimport { styles } from 'typestyles';\n\n// ❌ This file won't be transformed\nimport { styles } from '../path/to/typestyles';\n```\n\n## Performance issues\n\n### Slow initial render\n\n**Check for:**\n\n1. Too many style definitions at once\n2. Creating styles inside components\n3. Very large CSS rules\n\n**Fixes:**\n\n1. Code split your styles\n2. Move style definitions to module level\n3. Simplify complex selectors\n\n### Memory leaks\n\n**Symptoms:** App gets slower over time, memory usage grows.\n\n**Common causes:**\n\n1. Creating styles in event handlers or components\n2. Dynamic style values generating infinite variations\n\n**Fix:**\n\n```ts\n// ❌ Never do this\nfunction Component() {\n  const styles = createStyles(); // Creates on every render\n}\n\n// ✅ Do this instead\nconst styles = createStyles(); // Create once at module level\n\nfunction Component() {\n  // Use existing styles\n}\n```\n\n## Debug mode\n\nEnable debug logging to see what's happening:\n\n```ts\n// Set in your app entry point\nif (typeof window !== 'undefined') {\n  (window as any).TYPESTYLES_DEBUG = true;\n}\n```\n\nThis will log:\n\n- When styles are created\n- When CSS is injected\n- Any warnings or errors\n\n## Getting help\n\nIf you're still stuck:\n\n1. **Check the documentation:** Review the relevant guide for your use case\n2. **Search issues:** Look for similar problems in GitHub issues\n3. **Create a minimal reproduction:**\n   - Create the smallest possible example that shows the issue\n   - Share the code and expected vs actual behavior\n4. **Open an issue:** Include:\n   - TypeScript version\n   - Bundler (Vite, webpack, etc.)\n   - Browser\n   - Minimal reproduction code\n\n## Quick checklist\n\nWhen something isn't working, check:\n\n- [ ] Is typestyles installed?\n- [ ] Are imports correct (named imports, not default)?\n- [ ] Are styles defined at module level (not in components)?\n- [ ] Are namespaces unique?\n- [ ] Is the component actually rendering?\n- [ ] Are there any JavaScript errors in console?\n- [ ] Are the class names in HTML what you expect?\n- [ ] Is the CSS present in the DOM (DevTools)?\n- [ ] For SSR: Is `collectStyles()` being used?\n- [ ] For themes: Are tokens being used (not hardcoded values)?\n",
    "title": "Troubleshooting",
    "description": "Common issues and how to fix them",
    "_meta": {
      "filePath": "troubleshooting.md",
      "fileName": "troubleshooting.md",
      "directory": ".",
      "extension": "md",
      "path": "troubleshooting"
    }
  },
  {
    "content": "\n# TypeScript Tips\n\nTypeStyles is built with TypeScript in mind. This guide covers tips for getting the most out of types.\n\n## Basic types\n\n### Style definitions\n\nTypeStyles automatically infers types from your definitions:\n\n```ts\nimport { styles } from 'typestyles';\n\n// Types are inferred automatically\nconst button = styles.create('button', {\n  base: {\n    padding: '8px 16px',\n    backgroundColor: '#0066ff',\n  },\n  primary: {\n    color: 'white',\n  },\n});\n\n// selector function is typed\nconst classes = button('base', 'primary');\n//     ^? string\n```\n\n### Token types\n\nToken references are typed as strings:\n\n```ts\nimport { tokens } from 'typestyles';\n\nconst color = tokens.create('color', {\n  primary: '#0066ff',\n  secondary: '#6b7280',\n});\n\n// color is typed with specific keys\ncolor.primary; // string\ncolor.secondary; // string\ncolor.tertiary; // Error: Property 'tertiary' does not exist\n```\n\n## Strict mode compatibility\n\nTypeStyles works great with TypeScript's strict mode. Ensure your `tsconfig.json` has:\n\n```json\n{\n  \"compilerOptions\": {\n    \"strict\": true,\n    \"noImplicitAny\": true,\n    \"strictNullChecks\": true,\n    \"strictFunctionTypes\": true\n  }\n}\n```\n\n## Extending types\n\n### Custom CSS properties\n\nIf you need custom CSS properties that aren't in the standard types:\n\n```ts\nimport { CSSProperties } from 'typestyles';\n\n// Extend the base type\ninterface CustomProperties extends CSSProperties {\n  '--custom-property'?: string;\n  '--theme-color'?: string;\n}\n\n// Use in your style definitions\nconst customStyles: Record<string, CustomProperties> = {\n  base: {\n    '--custom-property': 'value',\n    '--theme-color': '#0066ff',\n  },\n};\n```\n\n### Custom at-rules\n\nFor custom at-rules that TypeStyles doesn't know about:\n\n```ts\ninterface CustomAtRules extends CSSProperties {\n  '@layer'?: Record<string, CSSProperties>;\n}\n\nconst styles: Record<string, CustomAtRules> = {\n  base: {\n    '@layer': {\n      utilities: {\n        padding: '8px',\n      },\n    },\n  },\n};\n```\n\n## Component prop types\n\n### Typed variant props\n\nMake your component props type-safe:\n\n```ts\nimport { styles } from 'typestyles';\n\nconst button = styles.create('button', {\n  base: { ... },\n  primary: { ... },\n  secondary: { ... },\n  ghost: { ... },\n  small: { ... },\n  medium: { ... },\n  large: { ... },\n});\n\n// Extract variant types\ntype ButtonVariants = Parameters<typeof button>;\n//   ^? ('base' | 'primary' | 'secondary' | 'ghost' | 'small' | 'medium' | 'large' | false | null | undefined)[]\n\n// Or define explicitly\ninterface ButtonProps {\n  variant?: 'primary' | 'secondary' | 'ghost';\n  size?: 'small' | 'medium' | 'large';\n  children: React.ReactNode;\n}\n\nfunction Button({ variant = 'primary', size = 'medium', children }: ButtonProps) {\n  return (\n    <button className={button('base', variant, size)}>\n      {children}\n    </button>\n  );\n}\n```\n\n### Strict variant checking\n\nUse `as const` for stricter variant checking:\n\n```ts\nconst button = styles.create('button', {\n  base: { ... },\n  primary: { ... },\n  secondary: { ... },\n} as const);\n\n// Without as const: variant accepts any string\n// With as const: variant only accepts 'base' | 'primary' | 'secondary'\n```\n\n## Utility types\n\n### Extracting style types\n\n```ts\nimport { styles } from 'typestyles';\n\nconst card = styles.create('card', {\n  base: { ... },\n  elevated: { ... },\n});\n\n// Get the style definition type\ntype CardStyle = Parameters<typeof card>[number];\n//   ^? 'base' | 'elevated' | null | undefined | false\n\n// Create a type for your component props\ntype CardProps = {\n  variant?: Extract<CardStyle, string>; // Only the string variants\n};\n```\n\n### Token type extraction\n\n```ts\nconst tokens = {\n  color: tokens.create('color', {\n    primary: '#0066ff',\n    secondary: '#6b7280',\n  }),\n  space: tokens.create('space', {\n    sm: '8px',\n    md: '16px',\n  }),\n};\n\n// Extract specific token types\ntype ColorToken = keyof typeof tokens.color;\n//   ^? 'primary' | 'secondary'\n\ntype SpaceToken = keyof typeof tokens.space;\n//   ^? 'sm' | 'md'\n```\n\n## Type-safe themes\n\n### Theme type definition\n\n```ts\n// types/theme.ts\nexport interface Theme {\n  color: {\n    primary: string;\n    secondary: string;\n    text: string;\n    surface: string;\n  };\n  space: {\n    sm: string;\n    md: string;\n    lg: string;\n  };\n}\n\n// Ensure your tokens match the theme\nexport const color = tokens.create('color', {\n  primary: '#0066ff',\n  secondary: '#6b7280',\n  text: '#111827',\n  surface: '#ffffff',\n});\n\n// TypeScript will error if you miss a key\n```\n\n### Theme-aware components\n\n```ts\ninterface ThemedComponentProps {\n  color: keyof typeof tokens.color;\n  space: keyof typeof tokens.space;\n}\n\nfunction ThemedComponent({ color, space }: ThemedComponentProps) {\n  const styles = {\n    color: tokens.color[color],\n    padding: tokens.space[space],\n  };\n\n  return <div style={styles}>Content</div>;\n}\n\n// Usage with autocomplete:\n// <ThemedComponent color=\"primary\" space=\"md\" />\n```\n\n## Generic components\n\n### Generic style components\n\n```ts\nimport { styles } from 'typestyles';\n\n// Generic component that accepts any style set\nfunction StyledBox<T extends string>({\n  styleSet,\n  variant,\n  children,\n}: {\n  styleSet: { (...variants: (T | false | null | undefined)[]): string };\n  variant?: T;\n  children: React.ReactNode;\n}) {\n  return <div className={styleSet('base', variant)}>{children}</div>;\n}\n\n// Usage\nconst box = styles.create('box', {\n  base: { padding: '16px' },\n  elevated: { boxShadow: '0 4px 6px rgba(0,0,0,0.1)' },\n});\n\n<StyledBox styleSet={box} variant=\"elevated\">\n  Content\n</StyledBox>;\n```\n\n## Conditional types\n\n### Responsive style types\n\n```ts\ntype Breakpoint = 'sm' | 'md' | 'lg' | 'xl';\n\ntype ResponsiveValue<T> = T | Partial<Record<Breakpoint, T>>;\n\ninterface ResponsiveProps {\n  padding: ResponsiveValue<string>;\n  display: ResponsiveValue<'block' | 'flex' | 'grid'>;\n}\n\n// Implementation would handle responsive logic\n```\n\n### Variant combinations\n\n```ts\n// Type for all possible button combinations\ntype ButtonVariant =\n  | { variant: 'primary'; size: 'small' | 'medium' | 'large' }\n  | { variant: 'secondary'; size: 'small' | 'medium' | 'large' }\n  | { variant: 'ghost'; size: 'small' | 'medium' };\n\nfunction Button(props: ButtonVariant & { children: React.ReactNode }) {\n  const { variant, size, children } = props;\n  // Implementation\n}\n\n// TypeScript enforces valid combinations:\nButton({ variant: 'primary', size: 'large', children: 'Click' }); // ✓\nButton({ variant: 'ghost', size: 'large', children: 'Click' }); // ✗ Error: 'large' not assignable\n```\n\n## Module augmentation\n\n### Extending typestyles types\n\nIf you need to add custom types to typestyles:\n\n```ts\n// types/typestyles.d.ts\ndeclare module 'typestyles' {\n  export interface CSSProperties {\n    // Add custom properties\n    'anchor-name'?: string;\n    'position-anchor'?: string;\n\n    // Add custom values to existing properties\n    display?: 'block' | 'flex' | 'grid' | 'custom-value';\n  }\n}\n```\n\n## Type guards\n\n### Safe variant checking\n\n```ts\nfunction isValidVariant(\n  variant: string\n): variant is 'primary' | 'secondary' | 'ghost' {\n  return ['primary', 'secondary', 'ghost'].includes(variant);\n}\n\nfunction Button({ variant }: { variant?: string }) {\n  const safeVariant = variant && isValidVariant(variant) ? variant : 'primary';\n\n  return <button className={button('base', safeVariant)}>Click</button>;\n}\n```\n\n## Configuration types\n\n### Strict style configuration\n\n```ts\n// styles/config.ts\nimport { styles } from 'typestyles';\n\ninterface StyleConfig<V extends string> {\n  namespace: string;\n  variants: Record<V, CSSProperties>;\n}\n\nfunction createStrictStyles<V extends string>(config: StyleConfig<V>) {\n  return styles.create(config.namespace, config.variants);\n}\n\n// Usage with full type safety\nconst button = createStrictStyles({\n  namespace: 'button',\n  variants: {\n    base: { padding: '8px' },\n    primary: { backgroundColor: 'blue' },\n  },\n});\n\n// TypeScript knows these are the only valid variants\nbutton('base', 'primary'); // ✓\nbutton('invalid'); // ✗ Type error\n```\n\n## Type narrowing\n\n### Narrowing with type predicates\n\n```ts\n// Define your variant type\ntype ButtonVariant = 'primary' | 'secondary' | 'ghost';\n\n// Type predicate function\nfunction isButtonVariant(value: string): value is ButtonVariant {\n  return ['primary', 'secondary', 'ghost'].includes(value);\n}\n\n// Use in component\nfunction Button({ variant: variantProp }: { variant?: string }) {\n  const variant: ButtonVariant = isButtonVariant(variantProp ?? '')\n    ? variantProp\n    : 'primary';\n\n  return <button className={button('base', variant)}>Click</button>;\n}\n```\n\n## Best practices\n\n1. **Let types be inferred** when possible\n2. **Define explicit interfaces** for component props\n3. **Use `as const`** for stricter variant checking\n4. **Extract shared types** to avoid duplication\n5. **Leverage `keyof`** for token-based props\n6. **Use strict mode** for best type safety\n7. **Export types** that consumers might need\n8. **Document complex types** with JSDoc comments\n\n## Common type issues\n\n### Issue: \"Type instantiation is excessively deep\"\n\nThis can happen with very complex nested styles. Solution: simplify nesting or add explicit type annotations.\n\n```ts\n// If you get deep type errors, add explicit return type\nconst complex = styles.create('complex', {\n  base: {\n    // very deep nesting\n  },\n} as const); // or use explicit type annotation\n```\n\n### Issue: \"Property does not exist\"\n\nMake sure you're importing the correct types:\n\n```ts\n// ✅ Import from typestyles\nimport type { CSSProperties } from 'typestyles';\n\n// ❌ Don't use React's CSSProperties for styles\nimport type { CSSProperties } from 'react'; // Wrong!\n```\n\n### Issue: \"Excessively deep type instantiation\"\n\nBreak complex styles into smaller pieces:\n\n```ts\n// ❌ Avoid very complex single definitions\nconst complex = styles.create('complex', {\n  base: {\n    // hundreds of lines\n  },\n});\n\n// ✅ Break into logical groups\nconst header = styles.create('header', { ... });\nconst content = styles.create('content', { ... });\nconst footer = styles.create('footer', { ... });\n```\n\n## Summary\n\nTypeStyles provides excellent TypeScript support out of the box. Key points:\n\n- Types are inferred automatically\n- Strict mode is fully supported\n- You can extend types for custom use cases\n- Use explicit interfaces for component props\n- Leverage TypeScript's type system for variant safety\n",
    "title": "TypeScript Tips",
    "description": "TypeScript best practices and advanced types for typestyles",
    "_meta": {
      "filePath": "typescript-tips.md",
      "fileName": "typescript-tips.md",
      "directory": ".",
      "extension": "md",
      "path": "typescript-tips"
    }
  },
  {
    "content": "\n# Vite Plugin\n\nThe optional `@typestyles/vite` plugin enhances your development experience with Hot Module Replacement (HMR) and helpful warnings.\n\n## Installation\n\n```bash\nnpm install -D @typestyles/vite\n# or\npnpm add -D @typestyles/vite\n# or\nyarn add -D @typestyles/vite\n```\n\n## Basic setup\n\nAdd the plugin to your `vite.config.ts`:\n\n```ts\nimport { defineConfig } from 'vite';\nimport typestyles from '@typestyles/vite';\n\nexport default defineConfig({\n  plugins: [typestyles()],\n});\n```\n\n## Features\n\n### Hot Module Replacement (HMR)\n\nWithout the plugin, editing a style file causes a full page reload. With the plugin:\n\n- Style changes apply instantly\n- Component state is preserved\n- No flicker or re-render cascade\n\nThe plugin works by:\n\n1. Detecting when a module uses typestyles\n2. Injecting HMR accept handlers\n3. Invalidating affected style registrations on file change\n4. Triggering a targeted update instead of a full reload\n\n### Duplicate namespace warnings\n\nThe plugin warns you when multiple files use the same namespace:\n\n```\nStyle namespace \"button\" is also used in /path/to/other/file.ts.\nDuplicate namespaces cause class name collisions.\n```\n\nThis helps catch issues early, since duplicate namespaces can cause unexpected style overwrites.\n\n## Configuration\n\n### Disable duplicate warnings\n\nIf you have a legitimate use case for duplicate namespaces (uncommon), you can disable the warning:\n\n```ts\nimport { defineConfig } from 'vite';\nimport typestyles from '@typestyles/vite';\n\nexport default defineConfig({\n  plugins: [\n    typestyles({\n      warnDuplicates: false,\n    }),\n  ],\n});\n```\n\n## How HMR works\n\nWhen you save a file that imports from `typestyles`, the plugin:\n\n1. **Extracts namespaces**: Parses your code to find all `styles.create()`, `tokens.create()`, `createTheme()`, and `keyframes.create()` calls\n\n2. **Injects HMR code**: Adds Vite's `import.meta.hot` handlers to the module\n\n3. **On file change**:\n   - The HMR handler calls `invalidateKeys()` from `typestyles/hmr`\n   - Affected styles are removed from the internal registry\n   - The module re-executes with fresh style definitions\n   - New CSS is injected, replacing the old rules\n\n4. **State preserved**: React/Vue/Svelte components keep their state since only the module containing styles changed\n\n## Example: seeing HMR in action\n\nCreate a simple Vite app with typestyles:\n\n```ts\n// src/tokens.ts\nimport { tokens } from 'typestyles';\n\nexport const color = tokens.create('color', {\n  primary: '#0066ff',\n});\n\n// src/styles.ts\nimport { styles } from 'typestyles';\nimport { color } from './tokens';\n\nexport const button = styles.create('button', {\n  base: {\n    backgroundColor: color.primary,\n    padding: '8px 16px',\n  },\n});\n\n// src/main.ts\nimport { button } from './styles';\n\ndocument.getElementById('app').innerHTML = `\n  <button class=\"${button('base')}\">Click me</button>\n`;\n```\n\nRun the dev server:\n\n```bash\nnpm run dev\n```\n\nNow edit `src/tokens.ts` and change the primary color. The button updates instantly without a page reload!\n\n## Framework integration\n\nThe plugin works with any Vite-based framework:\n\n### React\n\n```bash\nnpm create vite@latest my-app -- --template react-ts\nnpm install typestyles @typestyles/vite\n```\n\n```ts\n// vite.config.ts\nimport { defineConfig } from 'vite';\nimport react from '@vitejs/plugin-react';\nimport typestyles from '@typestyles/vite';\n\nexport default defineConfig({\n  plugins: [react(), typestyles()],\n});\n```\n\n### Vue\n\n```bash\nnpm create vite@latest my-app -- --template vue-ts\nnpm install typestyles @typestyles/vite\n```\n\n```ts\n// vite.config.ts\nimport { defineConfig } from 'vite';\nimport vue from '@vitejs/plugin-vue';\nimport typestyles from '@typestyles/vite';\n\nexport default defineConfig({\n  plugins: [vue(), typestyles()],\n});\n```\n\n### Svelte\n\n```bash\nnpm create vite@latest my-app -- --template svelte-ts\nnpm install typestyles @typestyles/vite\n```\n\n```ts\n// vite.config.ts\nimport { defineConfig } from 'vite';\nimport { svelte } from '@sveltejs/vite-plugin-svelte';\nimport typestyles from '@typestyles/vite';\n\nexport default defineConfig({\n  plugins: [svelte(), typestyles()],\n});\n```\n\n## SSR with Vite\n\nThe plugin is development-only and doesn't affect SSR. For SSR, use `collectStyles()` from `typestyles/server` as described in the [SSR guide](./ssr).\n\n## Troubleshooting\n\n### HMR not working\n\n1. Check that the plugin is listed in `vite.config.ts`\n2. Ensure your files import from `'typestyles'` (not a relative path to the package)\n3. Verify `import.meta.hot` is available (dev mode, not production)\n\n### Duplicate namespace warnings appearing incorrectly\n\nThe detection is regex-based and may have false positives if you:\n\n- Have strings that look like typestyles calls in comments\n- Use variable names like `styles` for other purposes\n\nThese are rare and don't affect functionality—just ignore the warning or disable it.\n\n### Full reloads still happening\n\nSome changes require a full reload:\n\n- Adding/removing imports that affect the module graph\n- Changes to non-typestyles code in the same file\n- Type-only changes (TypeScript types don't affect runtime)\n\n### Plugin performance\n\nThe plugin adds minimal overhead:\n\n- Only transforms files that import from `'typestyles'`\n- Transformation is a simple regex match, not a full AST parse\n- No runtime code is added in production builds\n\n## Is the plugin required?\n\nNo. TypeStyles works perfectly without it. The plugin is purely a development convenience for:\n\n- Faster iteration with HMR\n- Early warning about duplicate namespaces\n\nIf you prefer full page reloads or use a different bundler, you don't need this plugin.\n\n## Future features\n\nPlanned enhancements (not yet implemented):\n\n- **Dead style detection**: Warn when styles are defined but never used\n- **Build-time extraction**: Optionally extract static styles to CSS files for production\n- **Source maps**: Map generated CSS back to your style definitions\n\nStay tuned to the [GitHub repository](https://github.com/yourusername/typestyles) for updates.\n",
    "title": "Vite Plugin",
    "description": "Enhance your Vite development experience with HMR and style validation",
    "_meta": {
      "filePath": "vite-plugin.md",
      "fileName": "vite-plugin.md",
      "directory": ".",
      "extension": "md",
      "path": "vite-plugin"
    }
  }
]